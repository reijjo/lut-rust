<!doctype html>
<html>
<head>
    <title>3_Object-Oriented programming in Rust</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Object-Oriented programming in Rust</h1><p class="book_summary"><p dir="ltr" style="text-align: left;">We've covered struct in week 2, and now we're adding to what we have learned.<br>Rust is primarily a functional and system-level language, but it also supports object-oriented programming (OOP). OOP concepts such as classes, object inheritance and encapsulation can be implemented in Rust in a slightly different way than in traditional OOP languages ​​such as C++ or Java. Rust's object-oriented programming model does not include the traditional class concept, but supports many of the same principles by using structs and impl blocks.</p></p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Rust and Object-oriented programming" class="font-weight-bold text-decoration-none" href="#ch15264">1. Rust and Object-oriented programming</a></li><li><a title="2. Objects and classes" class="font-weight-bold text-decoration-none" href="#ch15265">2. Objects and classes</a></li></ul></div><div class="book_chapter"><a name="ch15264"></a><h2>1. Rust and Object-oriented programming</h2><p dir="ltr" style="text-align: left;">In the following chapter, we will discuss concepts, commands and ways to implement classes in Rust similar to object-oriented programming.</p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15265"></a><h2>2. Objects and classes</h2><p dir="ltr" style="text-align: left;"></p>
<p dir="ltr"></p>
<div>
    <h3><strong></strong><strong>Structs</strong></h3>
    <p>In Rust, "objects" are created using struct structures. Structures can contain fields (attributes) that can be of any type.</p>
    <p></p>
    <pre>// Definitions of a struct<br><span class="" style="color: rgb(125, 159, 211);">struct </span>Car {<br>&nbsp;&nbsp;&nbsp; brand: <span><span class="" style="color: rgb(125, 159, 211);">String</span></span>,<br>&nbsp;&nbsp;&nbsp; model: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; year: <span class="" style="color: rgb(125, 159, 211);">u32</span>,<br>}</pre><br>
    <p></p>
    <h4><strong>Impl-block and instances</strong></h4>
    <p><strong></strong>impl blocks define the methods of the struct. This is Rust's way of attaching a behavior (function) to a structure, just like in object-oriented programming. Functions can be defined in the Impl block, which can be called when creating an instance of the class - an object. The implementation below creates a class from Car-struct with two methods and a function new that sets the user-supplied values ​​according to the Car-struct's information using the Self-trait.</p>
    <div>
        <pre><span class="" style="color: rgb(125, 159, 211);">impl </span>Car {<br>&nbsp;&nbsp;&nbsp; // A function that acts as a constructor<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>new(brand: &amp;str, model: &amp;str, year: u32) -&gt; Self {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Self {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brand: brand.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model: model.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method for printing the cars information<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_info(&amp;<span class="" style="color: rgb(125, 159, 211);">self</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Car: {} {} ({})", self.brand, self.model, self.year);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method for setting the year for the year that is given as a parameter<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>set_year(&amp;mut self, year: u32) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.year = year;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br></pre>
        <h4>Self-keyword</h4><div>Self is a keyword that refers to the type in which it occurs. Using it allows typing without having to repeat the type name. Often used inside methods, especially when you want to refer to an instance of a structure (or other type) or return an object of a certain type.<br><br>In this example, self refers to a structure defined as Car type. This means that Self is used instead of the structure name, keeping the code looking more generic and maintainable.<p><br></p>
        </div>
        <div><br></div>
        <h4>Constructor</h4>
    </div><div>A constructor is a special function responsible for creating and initializing objects within a class or structure. It can be used to determine the initial values ​​of the object and prepare the object for use.<br><br>Rust does not have a traditional "constructor" concept like many other object-oriented programming languages ​​(e.g. C++, Java). In Rust, objects are created and initialized using regular functions, but in practice you can define a separate function that acts like a constructor and returns a struct (or other type) object - in the example above, this function is named "new".<br><br>Rust's philosophy is more "no implicit constructors", i.e. it does not force you to define constructors in the same way as in many other languages, but the programmer can decide himself how to create an object.</div><div><br><pre>// A function that acts as a constructor
    <span class="" style="color: rgb(125, 159, 211);">fn </span>new(brand: &amp;str, model: &amp;str, year: u32) -&gt; Self {
        <span class="" style="color: rgb(125, 159, 211);">Self </span>{
            brand: brand.to_string(),
            model: model.to_string(),
            year,
        }
    }</pre>
        <p><span style="font-weight: normal;">This function acts as a constructor. It takes three variables as parameters (brand, model, year) and returns a new Car structure, where these parameter values are set as the values ​​of the class fields.</span></p>
    </div>
    <div><br></div>
    <h4><strong>Inheritance and traits</strong></h4>
    <p>Rust does not have traditional class inheritance, but <strong>traits </strong>(type interfaces) can be used to define common functions for different types. Traits work somewhat the same as interfaces in Java and C# languages. They cannot be used to determine whether a class inherits from something, only to define common functions.</p>
    <p><br></p>
    <h4><strong>Encapselation</strong></h4>Rust's ownership model guarantees encapsulation and memory management. Ownership and borrowing prevent errors, such as memory leaks, that are often associated with encapsulation in OOP models.<br><br>Full example below:</div><div><br></div>
<div>
    <pre>// Definition of a struct<br><span class="" style="color: rgb(125, 159, 211);">struct </span>Car {<br>&nbsp;&nbsp;&nbsp; brand: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; model: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; year: <span class="" style="color: rgb(125, 159, 211);">u32</span>,<br>}<br><span class="" style="color: rgb(125, 159, 211);">impl </span>Car {<br>&nbsp;&nbsp;&nbsp; // A function that acts as a constructor<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>new(brand: &amp;str, model: &amp;str, year: u32) -&gt; Self {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brand: brand.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model: model.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method to print the cars information<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_info(&amp;self) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Car: {} {} ({})", self.brand, self.model, self.year);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method for setting the year of the car<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>set_year(&amp;mut self, year: u32) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.year = year;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>// main function <br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Creation of the object<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> my_car = Car::new("Toyota", "Corolla", 2020);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // Using print method of the Car<br>&nbsp;&nbsp;&nbsp; my_car.print_info();<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // Changing the year attribute<br>&nbsp;&nbsp;&nbsp; my_car.set_year(2021);<br>&nbsp;&nbsp;&nbsp; my_car.print_info();<br>}</pre>
</div>Notice how the new command is called from the Car class - in the same style as the functions of the modules are used.<br><br>Program printing:<pre>Car: Toyota Corolla (2020)<br>Car: Toyota Corolla (2021)</pre>
<p></p><br><br>
<h4>Class that has classes inside it</h4>
<div>Sometimes it is useful to group classes/objects together, if we want, for example, to list instances of the same class while the program is running. In the example below, we create a new struct that contains a list of objects of the Car class.</div><div><br></div><div><pre>// Definition of a struct<br><span class="" style="color: rgb(125, 159, 211);">struct </span>Car {<br>&nbsp;&nbsp;&nbsp; brand: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; model: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; year: <span class="" style="color: rgb(125, 159, 211);">u32</span>,<br>}<br><span class="" style="color: rgb(125, 159, 211);">impl </span>Car {<br>&nbsp;&nbsp;&nbsp; // A function that acts as a constructor<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn new</span>(brand: &amp;<span class="" style="color: rgb(125, 159, 211);">str</span>, model: &amp;<span class="" style="color: rgb(125, 159, 211);">str</span>, year: <span class="" style="color: rgb(125, 159, 211);">u32</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brand: brand.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model: model.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method to print the cars information<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_info(&amp;<span class="" style="color: rgb(125, 159, 211);">self</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Car: {} {} ({})", self.brand, self.model, self.year);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method for setting the year of the car<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>set_year(&amp;<span class="" style="color: rgb(125, 159, 211);">mut self</span>, year: <span class="" style="color: rgb(125, 159, 211);">u32</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.year = year;<br>&nbsp;&nbsp;&nbsp; }<br>}</pre><br></div><div><br></div><div><pre><span class="" style="color: rgb(125, 159, 211);">struct </span>Garage {<br>&nbsp;&nbsp;&nbsp; cars: Vec&lt;<span class="" style="color: rgb(125, 159, 211);">Car</span>&gt;,<br>}</pre><br></div>
<pre><span class="" style="color: rgb(125, 159, 211);">impl </span>Garage {<br>&nbsp;&nbsp;&nbsp; // A constructor function<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>new() -&gt; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">Self </span>{ cars: Vec::new() }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // A method for adding a Car object<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>add_car(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>self, car: <span class="" style="color: rgb(125, 159, 211);">Car</span><span class="" style="color: rgb(51, 51, 51);">) </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.cars.push(car);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // A method for printing information of all Cars<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_all_cars(&amp;self) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>self.cars.is_empty() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Garage is empty.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="" style="color: rgb(125, 159, 211);">else </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>car <span class="" style="color: rgb(125, 159, 211);">in </span>&amp;self.cars {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; car.print_info();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>We modify the main function from before, removing the single print, and replace it with the print function of the Garage-struct. This print function calls the print_info method of each Car-struct inside the Garage instance.<br>Before printing, we add the cars to the Garage instance we created by calling the add_car method. The method pushes the Car instance into the list we created using the push function.<div><br></div>
<pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>mut my_garage = Garage::new();<br><br>&nbsp;&nbsp;&nbsp; // Let's create some Cars<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>car1 = Car::new("Toyota", "Corolla", 2020);<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>car2 = Car::new("Honda", "Civic", 2019);<br>&nbsp;&nbsp;&nbsp; <span><span class="" style="color: rgb(125, 159, 211);">let </span></span>car3 = Car::new("Ford", "Focus", 2021);<br><br>&nbsp;&nbsp;&nbsp; // Add the Car's to the Garage<br>&nbsp;&nbsp;&nbsp; my_garage.add_car(car1);<br>&nbsp;&nbsp;&nbsp; my_garage.add_car(car2);<br>&nbsp;&nbsp;&nbsp; my_garage.add_car(car3);<br><br>&nbsp;&nbsp;&nbsp; // Print information of all the cars<br>&nbsp;&nbsp;&nbsp; my_garage.print_all_cars();<br>}<br></pre>
<div>Program execution:</div>
<pre>Car: Toyota Corolla (2020)<br>Car: Honda Civic (2019)<br>Car: Ford Focus (2021) <br></pre>
<div><br></div>
<p></p></div><a href="#toc">&uarr; top</a>
</body>
</html>