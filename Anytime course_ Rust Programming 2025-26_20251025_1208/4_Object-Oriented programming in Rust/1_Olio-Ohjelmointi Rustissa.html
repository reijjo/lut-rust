<!doctype html>
<html>
<head>
    <title>1_Olio-Ohjelmointi Rustissa</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Olio-Ohjelmointi Rustissa</h1><p class="book_summary"><h4 dir="ltr" style="text-align: left;">Olio-Ohjelmointi Rustissa</h4><div>Olemme käsittelleet structia viikolla 2, ja nyt lisäämme oppimaamme.</div><div>Rust on ensisijaisesti funktionaalinen ja järjestelmätason kieli, mutta se tukee myös olio-ohjelmointia (OOP). OOP:n käsitteet, kuten luokat, olioiden perintö ja kapselointi, voidaan toteuttaa Rustissa hieman eri tavalla kuin perinteisissä OOP-kielissä kuten C++:ssa tai Javassa. Rustin olio-ohjelmointimalli ei sisällä perinteistä luokka-konseptia, mutta se tukee monia samoja periaatteita käyttämällä rakenteita (struct) ja impl-blokkeja.</div></p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Rust ja Olio-ohjelmointi" class="font-weight-bold text-decoration-none" href="#ch15262">1. Rust ja Olio-ohjelmointi</a></li><li><a title="2. Oliot ja luokat" class="font-weight-bold text-decoration-none" href="#ch15263">2. Oliot ja luokat</a></li></ul></div><div class="book_chapter"><a name="ch15262"></a><h2>1. Rust ja Olio-ohjelmointi</h2>Seuraavissa kappaleissa käsittelemme olio-ohjelmointiin liittyviä käsitteitä, komentoja, ja tapoja toteuttaa luokat Rustissa.<br></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15263"></a><h2>2. Oliot ja luokat</h2><p dir="ltr" style="text-align: left;"></p><p dir="ltr"></p><div><h3><strong></strong><strong>Rakenteet (Struct)</strong></h3><p>Rustissa
 luodaan "olioita" käyttäen struct-rakenteita. Rakenteet voivat sisältää
 kenttiä (attribuutteja), jotka voivat olla minkä tahansa tyyppisiä.</p><p></p><pre>// Rakenteen määrittely<br><span class="" style="color: rgb(125, 159, 211);">struct </span>Car {<br>&nbsp;&nbsp;&nbsp; brand: <span><span class="" style="color: rgb(125, 159, 211);">String</span></span>,<br>&nbsp;&nbsp;&nbsp; model: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; year: <span class="" style="color: rgb(125, 159, 211);">u32</span>,<br>}</pre><br><p></p><h4><strong>Toteutus (Impl-block)</strong></h4><p><strong></strong>impl-blokeissa
 määritellään rakenteen (struct) metodit. Tämä on Rustin tapa liittää 
käyttäytyminen (toiminto) rakenteeseen, aivan kuten olio-ohjelmoinnissa. Impl-blokissa voidaan määrittää funktioita, joita voi kutsua kun luo luokan instanssin, olion. Alla oleva implementaatio luo Car-structista luokan, jolla on kaksi metodia, ja funktio new, joka laittaa käyttäjän antamat arvot Car-structin tietojen mukaisesti Self-traitin avulla.<br></p><div><pre><span class="" style="color: rgb(125, 159, 211);">impl </span>Car {<br>&nbsp;&nbsp;&nbsp; // Konstruktorin kaltainen funktio<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>new(brand: &amp;str, model: &amp;str, year: u32) -&gt; Self {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Self {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brand: brand.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model: model.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Metodi auton tiedoille<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_info(&amp;<span class="" style="color: rgb(125, 159, 211);">self</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Car: {} {} ({})", self.brand, self.model, self.year);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Metodi auton valmistusvuoden päivittämiseen<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>set_year(&amp;mut self, year: u32) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.year = year;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br></pre><h4>Self-avainsana</h4><p><span style="font-weight: normal;">Self on avainsana, joka viittaa siihen tyyppiin, jossa se esiintyy. Sen käyttö mahdollistaa kirjoittamisen ilman, että tyypin nimeä tarvitsee toistaa. Käytetään usein metodien sisällä, erityisesti silloin, kun halutaan viitata rakenteen (tai muun tyyppisen) instanssiin tai palata tietyn tyyppiseen olioon.</span></p><div><p>Tässä esimerkissä self-viittaa rakenteeseen, joka on määritelty Car-tyypiksi. Tämä tarkoittaa, että Self käytetään rakenteen nimen sijasta, jolloin koodi pysyy yleisemmän ja ylläpidettävämmän näköisenä.</p><p><br></p></div><div><br></div><h4>Konstruktori</h4></div><p>Konstruktori on erityinen funktio, joka on vastuussa olioiden luomisesta ja alkuarvostamisesta luokan tai rakenteen sisällä. Sen avulla voidaan määrittää olion alkuperäiset arvot ja valmistella olio käyttöön. <br></p><div><p>Rustissa ei ole perinteistä "konstruktori"-käsitettä kuten monissa muissa olio-ohjelmointikielissä (esim. C++, Java). Rustissa olioiden luominen ja alustus tapahtuu käyttämällä tavallisia funktioita, mutta käytännössä voidaan määritellä erillinen funktio, joka toimii konstruktorin kaltaisena, ja palauttaa rakenteen (tai muun tyyppisen) olion - ylläolevassa esimerkissä tämä funktio on nimetty "new".</p><p>Rustin filosofia on enemmänkin "ei määritelty" (no implicit constructors), eli se ei pakota määrittelemään konstruktoreita samalla tavalla kuin monissa muissa kielissä, vaan ohjelmoija voi itse päättää, kuinka olio luodaan.</p><pre>// Konstruktorin kaltainen funktio
    <span class="" style="color: rgb(125, 159, 211);">fn </span>new(brand: &amp;str, model: &amp;str, year: u32) -&gt; Self {
        <span class="" style="color: rgb(125, 159, 211);">Self </span>{
            brand: brand.to_string(),
            model: model.to_string(),
            year,
        }
    }</pre><p><span style="font-weight: normal;">Tämä funktio toimii konstruktorina. Se ottaa parametrina kolme tietoa (brand, model, year) ja palauttaa uuden Car-rakenteen, jossa nämä tiedot on asetettu luokan kenttien arvoiksi.</span><br></p></div><div><br></div><h4><strong>Perintö ja traitit</strong></h4><p>Rustissa ei ole perinteistä luokkaperintöä, mutta voidaan käyttää <strong>traitteja</strong>
 (tyyppirajapintoja) määrittämään yhteisiä toimintoja eri tyypeille. 
Traitit toimivat hieman samalla tavalla kuin rajapinnat (interfaces) 
Java- ja C#-kielissä. Niillä ei voi määrittää sitä, onko jokin luokka 
periytyvä jostain, vain pelkästään määrittämään yhteisiä toimintoja.<br></p><p><br></p><h4><strong>Kapselointi</strong></h4><p>Rustin
 omistajuusmalli takaa kapseloinnin ja muistinhallinnan. Omistajuus 
(ownership) ja lainaukset (borrowing) estävät virheet, kuten 
muistivuodot, jotka usein liittyvät kapselointiin OOP-malleissa.</p><p>Kokonainen esimerkki alla:</p></div><div><pre>// Rakenteen määrittely<br><span class="" style="color: rgb(125, 159, 211);">struct </span>Car {<br>&nbsp;&nbsp;&nbsp; brand: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; model: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; year: <span class="" style="color: rgb(125, 159, 211);">u32</span>,<br>}<br><span class="" style="color: rgb(125, 159, 211);">impl </span>Car {<br>&nbsp;&nbsp;&nbsp; // Konstruktorin kaltainen funktio<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>new(brand: &amp;str, model: &amp;str, year: u32) -&gt; Self {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brand: brand.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model: model.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Metodi auton tiedoille<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_info(&amp;self) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Car: {} {} ({})", self.brand, self.model, self.year);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Metodi auton valmistusvuoden päivittämiseen<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>set_year(&amp;mut self, year: u32) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.year = year;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>// main funktio<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Luodaan olio<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> my_car = Car::new("Toyota", "Corolla", 2020);<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // Käytetään metodia<br>&nbsp;&nbsp;&nbsp; my_car.print_info();<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; // Muutetaan valmistusvuosi<br>&nbsp;&nbsp;&nbsp; my_car.set_year(2021);<br>&nbsp;&nbsp;&nbsp; my_car.print_info();<br>}</pre></div>Huomaa, miten new-komentoa kutstuaan Car-luokasta - samaan tyyliin kuin moduulien funktioita käytetään.<br><br>Ohjelman tulostus:<br><pre>Car: Toyota Corolla (2020)<br>Car: Toyota Corolla (2021)</pre><p></p><br><br><h4>Luokka joka sisältää muita luokkia</h4><div>Joskus on hyödyllistä ryhmittää luokkia/oliota yhteen, jos haluamme esimerkiksi listata saman luokan instanssit ohjelman ajon aikana. Alla olevassa esimerkissä luomme uuden structin, joka sisältää listan Car-luokan olioita.</div><div><br></div><div><pre>// Definition of a struct<br><span class="" style="color: rgb(125, 159, 211);">struct </span>Car {<br>&nbsp;&nbsp;&nbsp; brand: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; model: <span class="" style="color: rgb(125, 159, 211);">String</span>,<br>&nbsp;&nbsp;&nbsp; year: <span class="" style="color: rgb(125, 159, 211);">u32</span>,<br>}<br><span class="" style="color: rgb(125, 159, 211);">impl </span>Car {<br>&nbsp;&nbsp;&nbsp; // A function that acts as a constructor<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn new</span>(brand: &amp;<span class="" style="color: rgb(125, 159, 211);">str</span>, model: &amp;<span class="" style="color: rgb(125, 159, 211);">str</span>, year: <span class="" style="color: rgb(125, 159, 211);">u32</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brand: brand.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model: model.to_string(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method to print the cars information<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_info(&amp;<span class="" style="color: rgb(125, 159, 211);">self</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Car: {} {} ({})", self.brand, self.model, self.year);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // A method for setting the year of the car<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>set_year(&amp;<span class="" style="color: rgb(125, 159, 211);">mut self</span>, year: <span class="" style="color: rgb(125, 159, 211);">u32</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.year = year;<br>&nbsp;&nbsp;&nbsp; }<br>}</pre><br></div><div><br></div><div><pre><span class="" style="color: rgb(125, 159, 211);">struct </span>Garage {<br>&nbsp;&nbsp;&nbsp; cars: Vec&lt;<span class="" style="color: rgb(125, 159, 211);">Car</span>&gt;,<br>}</pre><br></div><pre><span class="" style="color: rgb(125, 159, 211);">impl </span>Garage {<br>&nbsp;&nbsp;&nbsp; // Konstruktorin kaltainen funktio<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>new() -&gt; <span class="" style="color: rgb(125, 159, 211);">Self </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">Self </span>{ cars: Vec::new() }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // Metodi auton lisäämiseksi<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>add_car(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>self, car: <span class="" style="color: rgb(125, 159, 211);">Car</span><span class="" style="color: rgb(51, 51, 51);">) </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.cars.push(car);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // Metodi auton listauksen tulostamiseen<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">fn </span>print_all_cars(&amp;self) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>self.cars.is_empty() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Garage is empty.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="" style="color: rgb(125, 159, 211);">else </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>car <span class="" style="color: rgb(125, 159, 211);">in </span>&amp;self.cars {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; car.print_info();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre><div><br></div><div>Muokkaamme aikaisempaa main-funktiota poistaen yksittäisen tulostuksen, ja korvaamme sen Garage-structin tulostusfunktiolla. Tämä tulostusfunktio kutsuu jokaisen Garage-instanssin sisälläolevan Car-structin print_info-metodia.</div><div>Ennen tulostusta lisäämme autot luomamme Garage-instanssin sisään add_car-metodia kutsumalla. Metodi puskee Car-instanssin luomamme listan sisään push-funktiota käyttämällä.<br></div><div><br></div><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>mut my_garage = Garage::new();<br><br>&nbsp;&nbsp;&nbsp; // Luodaan autoja<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>car1 = Car::new("Toyota", "Corolla", 2020);<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>car2 = Car::new("Honda", "Civic", 2019);<br>&nbsp;&nbsp;&nbsp; <span><span class="" style="color: rgb(125, 159, 211);">let </span></span>car3 = Car::new("Ford", "Focus", 2021);<br><br>&nbsp;&nbsp;&nbsp; // Lisätään autot talliin<br>&nbsp;&nbsp;&nbsp; my_garage.add_car(car1);<br>&nbsp;&nbsp;&nbsp; my_garage.add_car(car2);<br>&nbsp;&nbsp;&nbsp; my_garage.add_car(car3);<br><br>&nbsp;&nbsp;&nbsp; // Tulostetaan kaikki autot<br>&nbsp;&nbsp;&nbsp; my_garage.print_all_cars();<br>}<br></pre><div>Ohjelman ajo:</div><pre>Car: Toyota Corolla (2020)<br>Car: Honda Civic (2019)<br>Car: Ford Focus (2021) <br></pre><div><br></div><p></p></div><a href="#toc">&uarr; top</a>
</body>
</html>