<!doctype html>
<html>
<head>
    <title>1_Ownership ja datatyyppejä -materiaalit</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Ownership ja datatyyppejä -materiaalit</h1><p class="book_summary">Tällä viikolla käymme läpi Rustin Ownership-käsitettä, Tiedostojen 
manipulaatiota, Struct-rakenteen, moduulien perusteet sekä listat, 
vektorit ja hash mapit.</p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Rustin Ownership" class="font-weight-bold text-decoration-none" href="#ch15250">1. Rustin Ownership</a></li><li><a title="2. Structit, Vec-tietorakenne" class="font-weight-bold text-decoration-none" href="#ch15252">2. Structit, Vec-tietorakenne</a></li><li><a title="3. HashMap-rakenne" class="font-weight-bold text-decoration-none" href="#ch15255">3. HashMap-rakenne</a></li><li><a title="4. Tiedoston manipulaatio" class="font-weight-bold text-decoration-none" href="#ch15251">4. Tiedoston manipulaatio</a></li><li><a title="5. Moduuleista" class="font-weight-bold text-decoration-none" href="#ch15253">5. Moduuleista</a></li><li><a title="6. Enum-rakenne" class="font-weight-bold text-decoration-none" href="#ch15254">6. Enum-rakenne</a></li></ul></div><div class="book_chapter"><a name="ch15250"></a><h2>1. Rustin Ownership</h2><p dir="ltr" style="text-align: left;">Tässä luvussa käymme läpi, miten Rustin Ownership vaikuttaa muuttjien käyttöön, miksi sitä käytetään ja mitä hyötyä siitä on.</p>
<h4 dir="ltr" style="text-align: left;">Ownership</h4>
<p></p>Ownership on yksi Rustin keskeisistä ominaisuuksista, joka auttaa hallitsemaan muistia tehokkaasti ja turvallisesti ilman <a href="https://www.geeksforgeeks.org/garbage-collection-java/">roskankerääjää</a>. Se määrittelee, kuka omistaa tietyn datan ja kuinka dataa voidaan käyttää ohjelman suorituksen aikana. Tässä luvussa pureudumme tarkemmin siihen, miten ownership toimii ja millaisia sääntöjä se noudattaa.<p>Rustissa jokaisella muuttujalla on omistaja. Tämä omistaja on muuttuja, joka hallitsee tiettyä muistilohkoa. Omistajuuteen liittyy kolme tärkeää sääntöä:</p>
<ol>
    <li>Jokaisella datalla on täsmälleen yksi omistaja kerrallaan.</li>
    <li>Kun omistaja poistuu käytöstä, data vapautetaan automaattisesti muistista.</li>
    <li>Data voidaan siirtää uudelle omistajalle, mutta tällöin alkuperäinen omistaja menettää oikeutensa siihen.</li>
</ol>
<p>Nämä säännöt varmistavat, että ohjelmassa ei tapahdu muistin kaksoisvapautuksia tai käyttöä sen jälkeen, kun muistilohko on jo vapautettu.</p>
<p>Kun muuttujalle annetaan uusi omistaja, puhutaan omistajuuden siirrosta. Esimerkiksi, kun muuttujan arvo siirretään toiseen muuttujaan, alkuperäinen muuttuja ei enää omista kyseistä dataa, eikä sitä voida käyttää. Tämä on tärkeää ymmärtää, sillä Rustin kääntäjä estää yritykset käyttää dataa, jonka omistajuus on siirtynyt.</p>
<p>Tarkastellaan seuraavaa koodiesimerkkiä:</p>
<pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>s1 = String::from("Hei");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>s2 = s1; // Omistajuus siirtyy s1:ltä s2:lle<br>&nbsp;&nbsp;&nbsp; // println!("{}", s1); // Tämä aiheuttaa virheen, koska s1 ei enää omista dataa<br>&nbsp;&nbsp;&nbsp; println!("{}", s2); // Tämä toimii, koska s2 on nyt datan omistaja<br>}<br></pre>
<p>Kun s1 siirretään s2:lle, s1 menettää omistajuutensa, eikä sitä voi enää käyttää. Tämä toimintatapa auttaa ohjelmoijaa välttämään virheitä, jotka voisivat johtaa epäjohdonmukaiseen datan käyttöön tai muistiongelmiin.<br><br>Omistajuuden siirron lisäksi Rustissa voi käyttää myös lainauksia (refence, viittaus), joiden avulla dataa voidaan käyttää ilman omistajuuden siirtoa. Lainauksia on kahdenlaisia: muuttumattomia (immutable) ja muuttuvia (mutable) lainauksia. Muuttumattomien lainausten avulla dataa voi lukea, mutta sitä ei voi muokata. Muuttuvien lainausten avulla dataa voi muokata, mutta samalla datalla voi olla vain yksi muuttuva laina kerrallaan. Tämä estää useita rinnakkaisia muokkauksia, jotka voisivat johtaa virheelliseen tilaan.</p>
<p><br>Seuraavaksi käsittelemme lainauksen käytön periaatteet ja esimerkkejä siitä, miten omistajuutta voidaan hallita tehokkaasti erilaisissa tilanteissa.</p>
<p>Esimerkki muuttuvasta lainauksesta:</p>
<pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>mut s = String::from("Hei");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>r = &amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>s; // Luodaan muuttuva laina<br>&nbsp;&nbsp;&nbsp; r.push_str(", maailma!"); // Muokataan dataa lainan kautta<br>&nbsp;&nbsp;&nbsp; println!("{}", r); // Käytetään lainaa tulostukseen<br>}</pre>
<p></p>
<p>Tässä <em>s </em>antaa muuttuvan lainan <em>r</em>:lle. Lainan olemassaolon aikana <em>s</em>:ää ei voi käyttää suoraan, mikä varmistaa, että muokkaukset tehdään hallitusti.</p>
<p>Lainattua arvoa käyttämällä käytämme <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.push_str">push_str</a>-komentoa jotta voimme lisätä jo olemassa olevaan muuttujaan lisää tekstiä. Muutoksen jälkeen, printattaessamme muuttujan <em>r</em><span>, tulostuu:</span></p>
<p><span><em>Hei, maailma!</em></span></p>
<p><span><span><span>Kun muokkaamme <em>r</em></span></span></span><span><span><span><span>:än arvoa, muokkaamme siis </span></span></span></span><em><span><span><span><span><span>s</span></span></span></span></span></em><span><span><span><span><span><span>-muuttujan arvoa lainauksen kautta.</span></span></span></span></span></span><em><span><span><span><span><span><br></span></span></span></span></span></em></p>
<p><em><span><span><br></span></span></em></p>
<h3>Muuttumattomien ja muuttuvien lainausten yhdistäminen</h3>
<p>Rustin sääntöihin kuuluu, että muuttumatonta ja muuttuvaa lainausta ei voi olla samanaikaisesti. Tämä sääntö estää ristiriitaiset tilanteet, joissa muuttumatonta lainausta yritettäisiin käyttää, kun dataa samalla muokataan.</p>
<p>Esimerkki virheellisestä yhdistelmästä:</p>
<pre><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span><br><span>&nbsp;&nbsp;&nbsp;<span class="" style="color: rgb(125, 159, 211);"> let mut</span> s = String::from("Hei");</span><br><span></span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>r1 = &amp;s; // Muuttumaton laina</span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>r2 = &amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>s; // Muuttuva laina - virhe!</span><br><span>&nbsp;&nbsp; &nbsp;</span><br><span>&nbsp;&nbsp;&nbsp; println!("{}, {}", r1, r2); // Tämä ei toimi</span><br><span>}</span><br><span></span></pre><strong><br></strong>
<p>Rust antaa ylläolevaa koodia suoritettaessa virhekoodin, sekä selkeän syyn, miksi ohjelma ei käänny:<br></p>
<pre><span class="" style="color: rgb(239, 69, 64);">error</span>[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable<br>&nbsp;--&gt; src/main.rs:5:14<br>&nbsp; |<br>4 |&nbsp;&nbsp;&nbsp;&nbsp; let r1 = &amp;s; // Muuttumaton laina<br>&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">-- immutable borrow occurs here</span><br>5 |&nbsp;&nbsp;&nbsp;&nbsp; let r2 = &amp;mut s; // Muuttuva laina - virhe!<br>&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">^^^^^^ mutable borrow occurs here</span><br>6 |<br>7 |&nbsp;&nbsp;&nbsp;&nbsp; println!("{}, {}", r1, r2); // Tämä ei toimi<br>&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">-- immutable borrow later used here</span></pre>
<p>Tämä koodi ei siis käänny, koska muuttumatonta lainausta <em>r1</em><span> </span>ja muuttuvaa lainausta <em>r2</em> ei voi olla samanaikaisesti.<br></p>
<p></p>
<pre><br></pre>
<p><br></p>
<p><br></p>
<p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15252"></a><h2>2. Structit, Vec-tietorakenne</h2><h4><strong>Struct</strong><br><strong></strong></h4><span><p>Struct, tai structure, on mukautettu tietotyyppi, jonka avulla voit pakata yhteen ja nimetä useita toisiinsa liittyviä arvoja, jotka muodostavat merkityksellisen kokonaisuuden. Jos tunnet oliopohjaisen kielen, rakenne on kuin objektin tietoattribuutit. Tässä luvussa käydään läpi miten Structeja voidaan Rustissa luoda.<br></p><p>Seuraavassa on esimerkkejä struct-tyypistä:</p></span><pre><span>// struct</span><br><span><span class="" style="color: rgb(125, 159, 211);">struct </span>User {</span><br><span>&nbsp;&nbsp;&nbsp; username: <span class="" style="color: rgb(125, 159, 211);">String</span>,</span><br><span>&nbsp;&nbsp;&nbsp; email: <span class="" style="color: rgb(125, 159, 211);">String</span>,</span><br><span>&nbsp;&nbsp;&nbsp; sign_in_count: <span class="" style="color: rgb(125, 159, 211);">u64</span>,</span><br><span>&nbsp;&nbsp;&nbsp; active: <span class="" style="color: rgb(125, 159, 211);">bool</span>,</span><br><span>}</span><br><span></span><br><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>user1 = User {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; username: String::from("example_user"),</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; email: String::from("example@example.com"),</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sign_in_count: 1,</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; active: true,</span><br><span>&nbsp;&nbsp;&nbsp; };</span><br><span></span></pre><span><br>&nbsp;&nbsp;&nbsp; println!("Käyttäjän nimi: {}", user1.username);<br>}</span><strong><br><br><br></strong><span>Yllä luomme uuden struct-tyypin nimeltä User. User-tyypillä annoimme neljä kenttää: <br>username, joka on tyyppiä String, <br>email, joka on myös tyyppiä String, <br>sign_in_count, jonka tyyppi on unsigned integer 64, </span><strong><br></strong><span>active, jonka tyyppi on boolean.<br><br>Main-functiossa luomme uuden User-tyypin "ilmentymän", jolle annamme jokaiselle kentälle arvon. Luomisen jälkeen User-tyypin ilmentymä on tallennettu user1-muuttujaan. Voimme käyttää structin kenttien arvoja print-lauseessa näkemällämme tavalla:<br></span><pre><span>user1.username</span><br><span></span></pre><span>Tämä palauttaa username-kentän arvon user1-muuttujasta, joka tässä tapauksessa oli "example@example.com".<br><br></span><h4><span><strong>Struct-kenttien muuttaminen</strong></span><br><span><strong></strong></span></h4><span>Koska Rustissa on oletuksena muokkaamattomuus, saamme structistamme muokattavan vain tekemällä koko strucista muokattavan:<br><br></span><pre><span><span class="" style="color: rgb(125, 159, 211);">struct </span>User {
    username: <span class="" style="color: rgb(125, 159, 211);">String</span>,
    email: <span class="" style="color: rgb(125, 159, 211);">String</span>,
    sign_in_count: <span class="" style="color: rgb(125, 159, 211);">u64</span>,
    active: <span class="" style="color: rgb(125, 159, 211);">bool</span>,
}

<span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
    <span class="" style="color: rgb(125, 159, 211);">let mut </span>user1 = User {
        username: String::from("example_user"),
        email: String::from("example@example.com"),
        sign_in_count: 1,
        active: true,
    };

    // Muutetaan email-kenttää
    user1.email = String::from("new_email@example.com");
    user1.sign_in_count += 1;

    println!("Sähköposti: {}", user1.email);
}<br><br></span></pre><p><span><strong></strong></span><strong></strong></p><p>User-rakenteen määrittelyssä molemmissa esimerkeissä, käytimme omistettua String-tyyppiä sen sijaan, että olisimme käyttäneet string-sliceen perustuvaa &amp;str-tyyppiä. Tämä on tarkoituksellinen valinta, koska haluamme jokaisen tämän rakenteen instanssin omistavan kaiken tietonsa, ja että tiedot pysyvät voimassa niin kauan kuin koko rakenne on voimassa.</p><p>On myös mahdollista, että rakenteet tallentavat viitteitä (reference) johonkin muualle omistettuihin tietoihin, mutta tämä edellyttää elinkaarien (lifetimes) käyttöä, joka on Rustin ominaisuus. Elinkaaret varmistavat, että rakenteen viittaamat tiedot pysyvät voimassa niin kauan kuin itse rakenne on voimassa. Elinkaarista lisätietoa <a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html">kirjan luvussa 10.</a><br></p><br><h4>Vec-tietorakenne</h4><div><p>Rustissa lista vastaa tietorakennetta, jolla voidaan tallentaa ja käsitellä tietoelementtejä peräkkäisessä järjestyksessä. Rustissa käytetään kuitenkin pääasiassa Vec (vektori) -tietotyyppiä listojen tapaan. Vec on dynaamisesti koon mukaan mukautuva taulukko.</p><h5>Vektorin ominaisuudet</h5><ul><li>Dynaaminen koko: Vektori voi kasvaa ja pienentyä ohjelman suorituksen aikana.</li><li>Homogeeninen tietotyyppi: Kaikkien elementtien täytyy olla samaa tyyppiä.</li><li>Erittäin tehokas ja muistinhallinnaltaan turvallinen.</li></ul><div>Kun luomme uuden Vec-listan, pitää meidän antaa sille tyyppi. Alla olevassa esimerkissä käytämme tyyppiä i32. Koska Vektori on homogeeninen tietotyyppi, voi se sisältää vain samankaltaisia tyyppejä. Jos haluamme listan sisältävän enemmän kuin pelkkiä numeroita. Voimme luoda uuden struct-tyypin, joiden kentissä on merkkijonoarvoja, numeroita, ja vaikkapa boolean-arvoja. Tämän struct-tyypin voimme tallettaa Vec-rakenteen sisälle, jolloin voimme kiertää tämän rajoituksen.</div><div><br></div>Katsotaan yksinkertaista esimerkkiä Vec-rakenteesta:</div><div><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Uuden vektorin luominen<br>    // Annetaan tyypiksi i32 ja alustetaan tyhjäksi<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> numbers: Vec&lt;i32&gt; = Vec::new();<br>&nbsp;&nbsp;&nbsp; // Alkioiden lisääminen<br>&nbsp;&nbsp;&nbsp; numbers.push(10);<br>&nbsp;&nbsp;&nbsp; numbers.push(20);<br>&nbsp;&nbsp;&nbsp; numbers.push(30);<br><br>&nbsp;&nbsp;&nbsp; println!("Vektorin sisältö: {:?}", numbers);<br>&nbsp;&nbsp;&nbsp; // Alkion hakeminen indeksistä<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>first_element = numbers[0];<br>&nbsp;&nbsp;&nbsp; println!("Ensimmäinen alkio: {}", first_element);<br><br>&nbsp;&nbsp;&nbsp; // Alkion muokkaaminen<br>&nbsp;&nbsp;&nbsp; numbers[1] = 25;<br>&nbsp;&nbsp;&nbsp; println!("Päivitetty vektori: {:?}", numbers);<br><br>&nbsp;&nbsp;&nbsp; // Iterointi<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>number <span class="" style="color: rgb(125, 159, 211);">in </span>&amp;numbers {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Arvo: {}", number);<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>Yllä oleva ohjelma tulostaa:</div><pre>Vektorin sisältö: [10, 20, 30]<br>Ensimmäinen alkio: 10<br>Päivitetty vektori: [10, 25, 30]<br>Arvo: 10<br>Arvo: 25<br>Arvo: 30<br><br></pre><p>Voimme tallentaa muitakin arvoja listaan, kuten haluamamme struct-rakenteen joka sisältää eri arvoja, merkkijonosta numeroihin.</p><p>Alla esimerkkiohjelma, joka talletaa struct-rakenteen instansseja listaan, käyttää vec!-makroa uuden listan luontiin ja tulostaa listan sisällön.</p><p><br></p><p></p><div><pre>// Määritellään oma struct-tyyppi, joka sisältää eri tyyppisiä kenttiä</pre><pre><span class="" style="color: rgb(125, 159, 211);">struct </span>Henkilo {</pre><pre>&nbsp; &nbsp; nimi: <span class="" style="color: rgb(125, 159, 211);">String</span>,</pre><pre>&nbsp; &nbsp; ika: <span class="" style="color: rgb(125, 159, 211);">u32</span>,</pre><pre>&nbsp; &nbsp; aktiivinen: <span class="" style="color: rgb(125, 159, 211);">bool</span>,</pre><pre>}</pre><pre><br></pre><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</pre><pre>&nbsp; &nbsp; // Luodaan vektori, joka sisältää Henkilo-structeja</pre><pre>&nbsp; &nbsp; let henkilot: Vec&lt;Henkilo&gt; = vec![</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; Henkilo {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nimi: String::from("Matti Meikäläinen"),</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ika: 30,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aktiivinen: true,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; },</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; Henkilo {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nimi: String::from("Maija Virtanen"),</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ika: 25,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aktiivinen: false,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; },</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; Henkilo {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nimi: String::from("Pekka Peloton"),</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ika: 40,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aktiivinen: true,</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; },</pre><pre>&nbsp; &nbsp; ];</pre><pre>&nbsp; &nbsp; // Käydään vektori läpi ja tulostetaan jokaisen henkilön tiedot</pre><pre>&nbsp; &nbsp; for henkilo in henkilot {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; println!("Nimi: {}, Ikä: {}, Aktiivinen: {}", henkilo.nimi, henkilo.ika, henkilo.aktiivinen);</pre><pre>&nbsp; &nbsp; }</pre><pre>}</pre><br></div>Esimerkkiohjelman tulostus:<br><pre>Nimi: Matti Meikäläinen, Ikä: 30, Aktiivinen: true<br>Nimi: Maija Virtanen, Ikä: 25, Aktiivinen: false<br>Nimi: Pekka Peloton, Ikä: 40, Aktiivinen: true&nbsp; </pre><p></p><pre><br></pre><h5>vec!-makro</h5><div>Rust hyödyntää monia makroja, kuten println!-komennossa. Makron tunnistaa <strong>!</strong><span>-merkistä. Vektorityypille on olemassa makro <em>vec!</em> joka on Rustin tarjoama kätevä tapa luoda uusi vektori ilman manuaalista Vec::new() kutsua ja elementtien lisäämistä erikseen push-komennolla. Käytimme ylläolevassa esimerkissä tätä makroa structien lisäämisessä. Alla on yksinkertaisempi esimerkki makron käytöstä.</span></div><div><span><br></span></div><div><pre><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>numerot = vec![1, 2, 3, 4, 5];</span><br><span></span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>numero <span class="" style="color: rgb(125, 159, 211);">in </span>numerot {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Numero: {}", numero);</span><br><span>&nbsp;&nbsp;&nbsp; }</span><br><span>}</span><br><span></span></pre>Esimerkkiohjelman tulostus:<br><pre>Numero: 1<br>Numero: 2<br>Numero: 3<br>Numero: 4<br>Numero: 5</pre></div><pre><br></pre><p>Vec-rakenne antaa käyttöömme useita hyödyllisiä metodeja:</p><ul><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push">push</a>: lisää vektorin/listan loppuun antamasi arvon</li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.pop">pop</a>: poistaa viimeisimmän arvon vektorista</li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.get">get</a>: palauttaa Option-tyypin, turvallisempi tapa viitata vektorin elementtiin</li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.len">len</a>: palauttaa vektorin pituuden (elementtien määrän)</li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.remove">remove</a>: poistaa halutun elementin indeksin perusteella listasta</li><li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.is_empty">is_empty</a>: palauttaa true tai false, riippuen onko vektori tyhjä vai ei</li></ul><div><br></div><div>Vec-rakenne homogeenisyyden voi "kiertää" käyttämällä myös enum-rakennetta hyödyksi: lisää <a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#using-an-enum-to-store-multiple-types">kirjan kappaleessa 8</a> .<br></div><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15255"></a><h2>3. HashMap-rakenne</h2><h4 dir="ltr" style="text-align: left;">HashMap</h4><div>HashMap on tietorakenne, joka tallentaa avain-arvopareja. Se on osa std::collections -moduulia ja toimii tehokkaasti avaimen perusteella tapahtuvassa hakemisessa. HashMap käyttää hajautustaulukkoa (hash table) avainten nopeaan etsimiseen, lisäämiseen ja poistamiseen.</div><div><br></div><pre>use std::collections::HashMap;<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut </span>opiskelijat = HashMap::new();<br><br>&nbsp;&nbsp;&nbsp; // Lisätään avain-arvopareja<br>&nbsp;&nbsp;&nbsp; opiskelijat.insert("Matti", 25);<br>&nbsp;&nbsp;&nbsp; opiskelijat.insert("Anna", 22);<br>&nbsp;&nbsp;&nbsp; opiskelijat.insert("Pekka", 28);<br><br>&nbsp;&nbsp;&nbsp; // Haetaan arvo avaimella<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">if let</span> Some(ikä) = opiskelijat.get("Anna") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Anna on {} vuotta vanha.", ikä);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // Käydään kaikki parit läpi<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>(nimi, ikä) <span class="" style="color: rgb(125, 159, 211);">in </span>&amp;opiskelijat {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("{} on {} vuotta vanha.", nimi, ikä);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // Päivitetään arvo<br>&nbsp;&nbsp;&nbsp; opiskelijat.insert("Anna", 23);<br><br>&nbsp;&nbsp;&nbsp; // Poistetaan avain-arvopari<br>&nbsp;&nbsp;&nbsp; opiskelijat.remove("Pekka");<br>}</pre><div><br></div>HashMap toimii<strong> </strong><span><strong>jos arvot ovat implementoineet Eq ja Hash traitit</strong>.</span> Listaukset standardikirjastosta löytyville tyypeille jotka nämä traitit ovat implementoineet löytyvät omilta sivuiltaan <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html#implementors">Eq-traitille</a> ja <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html#implementors">Hash-traitille</a>. Näihin tyyppeihin kuuluu esimerkiksi kokonaisluvut.<h4><br></h4><div>Hashmapilla on useita hyödyllisiä komentoja:</div><div><ul><li>HashMap::<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.new">new</a>() luo uuden hajaustaulukon</li><li><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert">insert</a>(avain, arvo) lisää avain-arvoparin tauluun</li><li><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get">get</a>(&amp;avain) palauttaa arvon viitteenä, jos avain löytyy taulusta</li><li><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert">insert</a>(avain, uusi_arvo) lisää uuden arvon vanhan tilalle</li><li><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove">remove</a>(&amp;avain) poistaa avain-arvoparin taulusta</li></ul><div>Huomaa, että "avain", "arvo" ja "uusi_arvo" ovat esimerkkinimiä muuttujalle, jotka pitää korvata oikealla muuttujanimellä edellä esitetyllä tavalla.</div></div></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15251"></a><h2>4. Tiedoston manipulaatio</h2><p dir="ltr" style="text-align: left;">Tiedostojen käsittely on yleinen tehtävä ohjelmoinnissa. Rust tarjoaa vahvat työkalut tiedostojen käsittelyyn käyttäen standardikirjastoa (<strong>std::fs</strong>). Rustissa voit kirjoittaa tiedostoon käyttämällä <span>std::fs::File-luokkaa</span> ja <span><em>write</em></span><span><em>!</em></span>-makroa tai std::io::Write-traitia. Alla esitetään ohjeita ja esimerkkejä siitä, miten käsitellä tiedostoja Rustissa.</p><p dir="ltr" style="text-align: left;">Alla main.rs tiedostoon tehty esimerkki:<br></p><pre>use std::fs::File;<br>use std::io::{self, Write};</pre><pre><span class="" style="background-color: rgb(255, 255, 255); color: rgb(125, 159, 211);">fn </span>main() -&gt; <span class="" style="color: rgb(239, 69, 64);">io</span>::Result&lt;()&gt; {<br>&nbsp;&nbsp;&nbsp; // Pyydetään käyttäjältä syöte<br>&nbsp;&nbsp;&nbsp; println!("Kirjoita jotain tallennettavaksi tiedostoon:");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> syote = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>syote)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .expect("Syötteen lukeminen epäonnistui!");<br>&nbsp;&nbsp;&nbsp; // Luodaan tai ylikirjoitetaan tiedosto kirjoittamista varten<br>&nbsp;&nbsp;&nbsp;<span class="" style="color: rgb(125, 159, 211);"> let mut</span> tiedosto = <span class="" style="color: rgb(239, 69, 64);">File</span>::create("syote.txt")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .expect("Tiedoston luominen epäonnistui!");<br>&nbsp;&nbsp;&nbsp; // Kirjoitetaan käyttäjän syöte tiedostoon<br>&nbsp;&nbsp;&nbsp; tiedosto<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .write_all(syote.as_bytes())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .expect("Kirjoittaminen tiedostoon epäonnistui!");<br>&nbsp;&nbsp;&nbsp; println!("Syöte tallennettu tiedostoon 'syote.txt'.");<br>&nbsp;&nbsp;&nbsp; Ok(())<br>}</pre><p dir="ltr" style="text-align: left;">Esimerkissä pyydämme käyttäjältä arvon ja tallennamme sen muuttuvaan muuttujaan.</p><p dir="ltr" style="text-align: left;">Luomme tiedoston nimeltä syote.txt ja kirjoitamme <a href="https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all">write_all</a>-komennon avulla käyttäjän antaman syötteen tiedostoon. Write_all yrittää kirjoittaa kaiken annetun datan, kunnes dataa ei ole.</p><p dir="ltr" style="text-align: left;">Yksinkertaisemmin voimme käyttäjän read_line syötteen kirjoittaa tiedostoon myös <a href="https://doc.rust-lang.org/std/macro.writeln.html">writeln!</a>-makrolla, korvaten tiedoston write_all käytön:<br></p><div><pre>writeln!(tiedosto, "{}", syote.trim()).unwrap();</pre></div>writeln! -makrossa on ensimmäisenä tiedosto mihin tallennetaan, seuraavaksi annetaan { } println!-makrosta tutulla tavalla, ja kolmanneksi annamme halutun syötteen.<br>Jos emme tarvitse tekstin formatointia, voimme antaa haluamamme arvon jo toisena parametrina.<p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15253"></a><h2>5. Moduuleista</h2><h4 dir="ltr" style="text-align: left;">Mitä ovat moduulit?</h4><div><p>Moduulit Rustissa ovat keino organisoida ja ryhmitellä ohjelmakoodia loogisiin osiin. Moduulit auttavat pitämään koodin siistinä ja helposti hallittavana, etenkin suurissa projekteissa. Moduulien avulla voit myös hallita koodin näkyvyyttä siten, että osa koodista on julkista (<em>pub</em>) ja osa yksityistä.</p><p>Rustissa jokainen tiedosto voi toimia moduulina, mutta voit myös luoda alakohtaisia moduuleita saman tiedoston sisälle <em>mod</em>-vainsanalla. Moduulit mahdollistavat uudelleenkäytettävien koodikomponenttien erottamisen.</p><br></div><div><br></div><h4>Miten luoda oma moduuli ja käyttää sitä?<br></h4><div><p>Oman moduulin luominen Rustissa tapahtuu <em>mod</em>-avainsanalla. Voit luoda moduulin joko suoraan tiedostoon tai alakohtaisena moduulina.</p><p>Esimerkki yksinkertaisesta moduulista samassa tiedostossa:</p></div><div><pre><span class="" style="color: rgb(125, 159, 211);">mod </span>utilities {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">pub fn</span> greet(name: &amp;<span class="" style="color: rgb(125, 159, 211);">str</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Hei, {}!", name);<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>Tässä moduuli utilities sisältää julkisen funktion <em>greet</em>. Huomaa <em>pub</em>-avainsana, joka tekee funktion näkyväksi moduulin ulkopuolelle.</div><div>Yleisemmin moduuleita käytetään omassa kansiossa. Alla näemme <em>cargo new project</em> -komennon jälkeisen kansiohierarkian:</div><div><img src="data/kuva.png" alt="" role="presentation" class="img-fluid"></div><div><br></div><div>Luodaksesi oman moduulin, luo kansio <em>src</em>-kansion sisälle haluamallasi nimellä. Luo kansioon uusi Rust-tiedosto ja anna sille nimi. Luo myös<em> mod.rs</em>, jonne lisäät:</div><div><em>pub mod {antamasi_nimi}</em>;</div><div>Tämän jälkeen kansiohierarkiasi pitäisi näyttää samankaltaiselta kuin alla. Loin kansion nimeltä <em>project_module</em>, loin kansioon tiedoston nimeltä<em> avustus_tiedosto.rs</em>, sekä <em>mod.rs.<br></em></div><div><img src="data/kuva%20%284%29.png" alt="" role="presentation" class="img-fluid"><br></div><div><br></div><div>mod.rs tiedoston sisältö:</div><div><div><pre><span class="" style="color: rgb(125, 159, 211);">pub mod</span> avustus_tiedosto;</pre></div><br></div><p><span style="font-weight: normal;"><em>avustus_tiedostoon </em>tein esimerkkifunktion, jota kutsumme main.rs tiedostossa. Funktio tarvitsee <em>pub</em>-avainsanan, jotta voimme kutsua sitä. <em>avustus_tiedosto</em>:n sisältö:<br></span></p><p><span style="font-weight: normal;"></span></p><div><pre><span class="" style="color: rgb(125, 159, 211);">pub fn</span> tulostus_funktio(name: &amp;<span class="" style="color: rgb(125, 159, 211);">str</span>) {<br>&nbsp;&nbsp;&nbsp; println!("Nimesi näyttää olevan {}.", name);<br>}</pre><br></div><div>main.rs tiedostossa kutsun funktiota, mutta sitä ennen tuon moduulin käytettäväkseni use-komennolla, ja määritän avustus_tiedoston käytettäväkseni. Esimerkki alla:</div><div><br></div><div><pre><span class="" style="color: rgb(125, 159, 211);">pub mod</span> project_module;<br>use project_module::avustus_tiedosto::tulostus_funktio;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; let kayttajan_nimi: &amp;<span class="" style="color: rgb(125, 159, 211);">str </span>= "Rust opiskelija";<br>&nbsp;&nbsp;&nbsp; tulostus_funktio(kayttajan_nimi);<br>}<br><br></pre>Ohjelma tulostaa:<br><pre>Nimesi näyttää olevan Rust opiskelija.</pre></div><p></p><div><br></div><div>Huomaa syntaksi: käyttämällä "<strong>::</strong>" voin kutsua funktiota <em>tulostus_funktio </em>tiedostosta <em>avustus_tiedosto</em>. Olisin voinut myös tuoda pelkän funktion käytettäväkseni, ja yksinkertaistaa funktiokutsua näin:</div><div><div><pre><span class="" style="color: rgb(125, 159, 211);">pub mod</span> project_module;<br><br>use project_module::avustus_tiedosto::tulostus_funktio;<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>    let kayttajan_nimi: &amp;<span class="" style="color: rgb(125, 159, 211);">str </span>= "Rust opiskelija";<br><br>    tulostus_funktio(kayttajan_nimi);<br>}<br><br><br></pre>Näin en joudu käyttämään moduulin nimeä funktion kutsussa. Jos moduuleita on paljon, voi olla selkeämpää jättää funktion nimi ensimmäisen esimerkin tavalla.</div><div><br></div><div>Jos moduulissa on useampi funktio, voit tuoda kaikki funktiot syntaksilla " <strong>::*</strong> " alla näytetyllä tavalla. Luomme myös toisen funktion esimerkkiä varten <em>avustus_tiedosto </em>tiedostoon:</div><div><em><span><span>avustus_tiedosto</span>.rs</span>:</em><br></div><div><pre><span class="" style="color: rgb(125, 159, 211);">pub fn</span> tulostus_funktio(name: &amp;<span class="" style="color: rgb(125, 159, 211);">str</span>) {<br>    println!("Nimesi näyttää olevan {}.", name);<br>}<br><br><span class="" style="color: rgb(125, 159, 211);">pub fn</span> summaa_kaksi_numeroa(numero_1: <span class="" style="color: rgb(125, 159, 211);">i32</span>, numero_2: <span class="" style="color: rgb(125, 159, 211);">i32</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">i32 </span>{<br>    numero_1 + numero_2<br>}<br><br><br></pre></div></div><div>Main.rs:</div><div><div><pre><span><span class="" style="color: rgb(125, 159, 211);">pub mod</span> project_module;</span><br><span></span><br><span>use project_module::avustus_tiedosto::*;</span><br><span></span><br><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>kayttajan_nimi: &amp;<span class="" style="color: rgb(125, 159, 211);">str </span>= "Rust opiskelija";</span><br><span></span><br><span>&nbsp;&nbsp;&nbsp; tulostus_funktio(kayttajan_nimi);</span><br><span></span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>numero_1: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= 5;</span><br><span></span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>numero_2: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= 5;</span><br><span></span><br><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>summa: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= summaa_kaksi_numeroa(numero_1, numero_2);</span><br><span></span><br><span>&nbsp;&nbsp;&nbsp; println! {"{} + {} = {}", numero_1, numero_2, summa}</span><br><span>}</span></pre><br></div><div>Ohjelman tulostus:<br><pre>Nimesi näyttää olevan Rust opiskelija.<br>5 + 5 = 10</pre></div><br></div></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15254"></a><h2>6. Enum-rakenne</h2><p dir="ltr" style="text-align: left;"></p><h4>Enum-rakenne</h4><div><p></p></div>Rustin Enum-rakenne mahdollistaa luetteloitujen tyyppien (enumerations) määrittelyn. Enum rakennetta voidaan käyttää, kun halutaan ilmaista, että jokin muuttuja voi sisältää yhden useista vaihtoehdoista.<br><br><pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Väri {<br>&nbsp;&nbsp;&nbsp; Punainen,<br>&nbsp;&nbsp;&nbsp; Vihreä,<br>&nbsp;&nbsp;&nbsp; Sininen,<br>}<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>suosikki: <span class="" style="color: rgb(125, 159, 211);">Väri </span>= Väri::Vihreä;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>suosikki {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Väri::Punainen =&gt; println!("Punainen valittu!"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Väri::Vihreä =&gt; println!("Vihreä valittu!"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Väri::Sininen =&gt; println!("Sininen valittu!"),<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>Ylläolevassa esimerkissä luomme muuttujan nimeltä <em>suosikki</em><span>, joka on tyyppiä&nbsp;"Väri". Väri voi olla arvoltaan joko "Punainen", "Vihreä" tai "Sininen". Valitsemme värin käyttämällä "<strong>::</strong><span>" operaattoria. Tätä operaattoria käytetään enum-rakenteen lisäski myös moduulien ja funktioiden viittaamisessa (std::io, String::from("Hei") ). Tämä operaattori viittaa "polkuun" jolla päästään tiettyyn kohteeseen.<br>Käytämme ylläolevassa esimerkissä match-lausetta, joka tulostaa minkä värin valitsimme sen perusteella, minkä suosikki-muuttujalle annoimme.<br><br></span></span><h4><span><span>Enum-rakenne ja data</span></span></h4><p>Enum rakenne voi sisältää myös dataa. Olemme nähneet tästä jo esimerkin Option ja Result tyyppien parissa. Alla näemme erilaisen esimerkin:<br></p><pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Viesti {<br>&nbsp;&nbsp;&nbsp; Teksti(String),<br>&nbsp;&nbsp;&nbsp; Luku(i32),<br>&nbsp;&nbsp;&nbsp; Lopeta,<br>}<br><span class="" style="color: rgb(125, 159, 211);">fn </span>tulosta_viesti(viesti: <span class="" style="color: rgb(125, 159, 211);">Viesti</span>) {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>viesti {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Viesti::Teksti(s) =&gt; println!("Teksti: {}", s),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Viesti::Luku(n) =&gt; println!("Luku: {}", n),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Viesti::Lopeta =&gt; println!("Lopetusviesti"),<br>&nbsp;&nbsp;&nbsp; }<br>}<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>viesti = <span class="" style="color: rgb(125, 159, 211);">Viesti</span>::Luku(42);<br>&nbsp;&nbsp;&nbsp; tulosta_viesti(viesti);<br>}<br><br></pre><p>Luomme Enum-rakenteen nimeltä Viesti. Viesti voi olla kolmea tyyppiä, joista jokainen on erilainen. Teksti voi sisältää String-tyypin, Luku voi sisältää kokonaisluvu, ja Lopeta on itsenäinen String joka ei sisällä itsessään mitään. Samalla tavalla kuin aikaisemmassa esimerkissä, annamme muuttujallemme <em>viesti</em><span> haluamamme arvon, tässä tapauksessa kokonaisluvun, ja tulostamme sen käyttäen match lausetta.</span></p><p><span><br></span></p><h4><span>Enum ja Option sekä Result tyyppi</span></h4><div>Aikaisemmin kävimme läpi <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a> ja <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a> tyypit. Kun katsomme tarkemmin näitä tyyppejä, huomaamme, että ne ovat Enum-rakenteita.</div><div><br></div><div><pre><code><span class="" style="color: rgb(125, 159, 211);">pub enum </span>Result&lt;T, E&gt; {
   Ok(T),
   Err(E),
}</code></pre><pre><code><span class="" style="color: rgb(125, 159, 211);">pub enum</span> Option&lt;T&gt; {
    None,
    Some(T),
}</code></pre>Result sisältää kahta tyyppiä, joko haluamamme tyypin, tai errorin. Option sisältää joko None arvon, joka ei itsessään sisällä mitään, tai Some-tyypin, joka sisältää antamamme arvon T.</div><p></p></div><a href="#toc">&uarr; top</a>
</body>
</html>