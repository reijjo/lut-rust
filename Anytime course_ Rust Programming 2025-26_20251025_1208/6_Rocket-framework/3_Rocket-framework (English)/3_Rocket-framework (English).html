<!doctype html>
<html>
<head>
    <title>3_Rocket-framework (English)</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Rocket-framework (English)</h1><p class="book_summary">In this section, we will cover the backend implementation of web programming in Rust using the Rocket framework. We go through GET request, POST request, HTML data rendering, HTML form processing.</p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Using Rocket Framework" class="font-weight-bold text-decoration-none" href="#ch15280">1. Using Rocket Framework</a></li><li><a title="2. HTML Rendering" class="font-weight-bold text-decoration-none" href="#ch15281">2. HTML Rendering</a><ul><li><a title="2.1. Form-input" class="text-decoration-none" href="#ch15282">2.1. Form-input</a></li></ul></li><li><a title="3. POST-request and Postman tool" class="font-weight-bold text-decoration-none" href="#ch15283">3. POST-request and Postman tool</a></li></ul></div><div class="book_chapter"><a name="ch15280"></a><h2>1. Using Rocket Framework</h2><p dir="ltr" style="text-align: left;"></p><h4 dir="ltr">What is Rocket framework?</h4>Rocket is a web application framework developed for the Rust programming language, which enables the creation of fast, type-safe web applications easily.Its intuitive APIs make it approachable for developers of all backgrounds. Rocket offers, among other things, form processing and JSON data processing.<br>If you are not into web programming, you can find more information about get and post requests and HTTP requests in general <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">here</a>.<div><br></div><p dir="ltr"><br></p><h4 dir="ltr">Using Rocket framework - GET Request<br></h4><div>Let's look at using Rocket Framework through examples. Below is a new project whose main.rs file has been replaced with the code snippet below:</div><div><br><pre>#[macro_use] extern crate rocket;<br><br>#[get("/hello/&lt;name&gt;")]<br><span>fn </span>hello(name: <span>String</span>) -&gt; String {<br>&nbsp;&nbsp;&nbsp; format!("Hey, {}!", name)<br>}<br>#[launch]<br><span>fn </span>rocket() -&gt; _ {<br>&nbsp;&nbsp;&nbsp; rocket::build().mount("/", routes![hello])<br>}</pre>Let's go through the example code line by line.</div><div>Top row:</div><div><pre>#[macro_use] extern crate rocket;</pre></div><div>brings the attributes and macros used by Rocket such as #[get] and #[launch] into use. with the get macro we can make a get route.</div><p dir="ltr"><br></p><p dir="ltr"></p><p><span><span><span>#[get("/hello/&lt;name&gt;")]</span>:</span></span><br>This attribute specifies the route and parameter:<br><br>/hello specifies the path in the URL.</p><p>&lt;name&gt; denotes a dynamic parameter that is included from the URL (eg /hello/Matti).</p><br><span><br></span><pre><span><span>hello(name: String):</span></span><br><span></span></pre><p><span>A function that handles a GET request. The name parameter corresponds to the value given in the URL and is automatically converted to String type by Rocket.</span></p><p>Return:</p><pre>format!("Hey, {}!", name)<span></span><br><span></span></pre><p><span>The function returns a string that is created with the <a href="https://doc.rust-lang.org/std/macro.format.html">format</a>! macro. In this case, it greets the user based on the given name.</span></p><pre><span><span>#[launch] and rocket::build():<br><br></span></span><span></span></pre><p><span>This partlaunches the Rocket application:</span></p><pre><span>rocket::build().mount("/", routes![hello])</span></pre>Attaches the hello path to the root path of the application ( / ).<br><p></p><p dir="ltr">When the application is run with the cargo run command, the application should be started. When you make a request to the address with a browser or API tool:</p><pre>http://localhost:8000/hello/Matti</pre><p dir="ltr">The answer should be:</p><pre dir="ltr">Hey, Matti!<br><br></pre><p>When you run the application, you should see a bunch of text in the console of the IDE you're using, of which one should be:</p><pre>Rocket has launched from http://127.0.0.1:8000</pre><p>Copy this sentence and go to that address in your browser. You should get a 404 error. Remember that you only made the route to the /hello/&lt;parametri1&gt; address, so put any name you want after the above address, such as /hello/opiskelija. In this case, you should see the text:</p><p><span><span><img src="data/kuva.png" alt="" role="presentation"><br></span></span></p><p>And your console should have something similar:</p><pre dir="ltr"><img src="data/kuva%20%281%29.png" alt="" role="presentation"><br><br></pre>The response from the server, our program, was successful, the r<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">esponse code</a> was <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200">200</a>, and the program recognized that we made a request to the /hello/student address.<br><br>Note that the parameter name of the get-route function must be the same as the parameter we use in the route. In the case of our example, we use &lt;name&gt; in our route, and name as a parameter to our function.<pre dir="ltr"><br></pre><p dir="ltr"><a href="https://rocket.rs/guide/v0.5/introduction/#introduction">Rocket-framework documentation page</a></p><br><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15281"></a><h2>2. HTML Rendering</h2><p dir="ltr" style="text-align: left;"></p><h4>HTML rendering</h4>We can show the data to the user better in HTML format using the RawHtml module of the Rocket framework.<p><br></p><br><pre>#[macro_use] extern crate rocket;<br>use rocket::response::content::RawHtml;<br>#[get("/&lt;page_name&gt;")]<br><span class="" style="color: rgb(125, 159, 211);">fn </span>render_page(page_name: <span class="" style="color: rgb(125, 159, 211);">String</span>) -&gt; RawHtml&lt;&amp;'<span class="" style="color: rgb(125, 159, 211);">static str</span>&gt; {<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>content = <span class="" style="color: rgb(125, 159, 211);">match </span>page_name.as_str() {<br>        "welcome" =&gt; "&lt;h1&gt;Welcome!&lt;/h1&gt;&lt;p&gt;Happy to see you here.&lt;/p&gt;",<br>        "about" =&gt; "&lt;h1&gt;About us&lt;/h1&gt;&lt;p&gt;We are a Rocket example app.&lt;/p&gt;",<br>        _ =&gt; "&lt;p&gt;Page not found.&lt;/p&gt;",<br>    };<br>    RawHtml(content)<br>}<br>#[launch]<br><span class="" style="color: rgb(125, 159, 211);">fn </span>rocket() -&gt; _ {<br>    rocket::build().mount("/page", routes![render_page])<br>}<br><br></pre><p dir="ltr">In order to be able to display data in HTML format to the user, we need to return a value of type RawHTML that contains the HTML we want. As we can see, our function has a return type of RawHTML, and in order for the program to work, we must also set the lifetime for our return value.</p><p dir="ltr"><br></p><h4 dir="ltr">Why use the keyword 'static?<br></h4><p>Since RawHtml returns a reference (&amp;str) to the HTML content, the program must ensure that it does not attempt to use freed memory. 'static ensures that the returned HTML is always present during program execution.</p><br><h4 dir="ltr">Sample run</h4><p dir="ltr">When we run the code above, we get two sub-routes to the /page route, /welcome and /about. When we go to /about, we get a view like this:</p><p dir="ltr"><img src="data/kuva%20%281%29.png" alt="" role="presentation" class="img-fluid"><br></p><p dir="ltr"><br></p><p dir="ltr">As we can see, the information we send is rendered according to the HTML information we provide. "Tietoa meist√§" is in the H1 element, and "Olemme Rocket-esimerkkisovellus." -text is inside the p-element. You can find a list of different HTML elements here.</p><p dir="ltr">The most common elements are:</p><ul dir="ltr"><li><a href="https://www.w3schools.com/tags/tag_hn.asp">h1 ... h6</a> defines the header and its size</li><li><a href="https://www.w3schools.com/tags/tag_p.asp">p </a>normal text sections go inside this element</li><li><a href="https://www.w3schools.com/tags/tag_div.asp">div </a>is used to compartmentalize different sections in grouping</li><li><a href="https://www.w3schools.com/tags/tag_form.asp">form</a> a form format that can contain several different elements such as <a href="https://www.w3schools.com/tags/tag_button.asp">button</a>, <a href="https://www.w3schools.com/tags/tag_input.asp">input</a></li><li>there are many different options for the input type, such as checkbox, submit, radio, range</li></ul><div><br></div><div><br></div><div><br></div><br><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15282"></a><h3>2.1. Form-input</h3><p dir="ltr" style="text-align: left;"></p><h4 dir="ltr">Example of using form</h4><div>Below is sample code for rendering a form using the RawHtml function. We define input elements inside the form, giving them the types we want.</div><div><br></div><div><div><pre>#[macro_use]<br>extern crate rocket;<br>use rocket::form::{Form, FromForm};<br>use rocket::response::content::RawHtml;<br>#[derive(FromForm)]<br><br>struct UserInput {<br>    name: String,<br>    age: u32,<br>}<br><br>#[post("/submit", data = "&lt;user_form&gt;")]<br>fn handle_form(user_form: Form&lt;UserInput&gt;) -&gt; String {<br>    let user = user_form.into_inner();<br><br>    format!("User: {} ({}) years old", user.name, user.age)<br>}<br><br>#[get("/form")]<br>fn form_page() -&gt; RawHtml&lt;&amp;'static str&gt; {<br>    let rendered_page: &amp;str = r#"<br><br>    &lt;form action="/submit" method="post"&gt;<br><br>        &lt;label for="name"&gt;Name:&lt;/label&gt;<br><br>        &lt;input type="text" id="name" name="name" required&gt;<br><br>        &lt;br&gt;<br><br>        &lt;label for="age"&gt;Age:&lt;/label&gt;<br><br>        &lt;input type="number" id="age" name="age" required&gt;<br><br>        &lt;br&gt;&lt;br&gt;<br><br>        &lt;input type="submit" value="Submit"&gt;<br><br>    &lt;/form&gt;<br><br>    "#;<br><br>    RawHtml(rendered_page)<br>}<br><br>#[launch]<br><br>fn rocket() -&gt; _ {<br>    rocket::build().mount("/", routes![form_page, handle_form])<br>}<br><br><br><br></pre><p>We use new features from the Rocket library - Form, and FromForm. The #[derive(FromForm)] attribute enables automatic filling of a Rust structure - struct - from form data using Rocket.</p><p><br></p><h4><strong>How does it work?</strong></h4><p>Rocket parses the fields received from POST or GET form requests and fills them into the corresponding fields of the structure. The names match the names of the fields in the HTML form.</p><pre>#[derive(FromForm)]
struct UserInput {
    name: String,
    age: u32,
}<br><br></pre></div>The UserInput structure above receives the following HTML form fields:</div><div><pre>&lt;form action="/submit" method="post"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;input type="text" name="name"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;input type="number" name="age"&gt;<br>&lt;/form&gt;<br><br></pre><h5><strong>Validation</strong></h5><p>If the form data is missing, doesn't match, or contains the wrong type of value (e.g. text in a number field), Rocket returns an error related to form processing.</p><p><br></p><h5><strong>F</strong><strong>orm </strong><strong>Data Guard</strong></h5><p>Form&lt;UserInput&gt; is a <a href="https://api.rocket.rs/v0.5/rocket/data/trait.FromData#data-guards">data guard</a> provided by Rocket that ensures that the form data is in the correct format and can be converted to the defined Rust structure.</p><p><br></p><h5><strong>How does Form work?</strong></h5><p>Rocket automatically reads the form data from the body of the HTTP request, performs the FromForm conversion, and if the conversion is successful, provides access to the data structure.</p><ul><li>data = "&lt;user_form&gt;" tells Rocket that it expects to receive data to be stored in the user_form variable</li><li>Form&lt;UserInput&gt; reads and checks the data</li><li>user_form.into_inner() returns the actual UserInput structure for processing.</li></ul><div>After this, the variable user in our example is an instance of the UserInput type, whose fields name and age we can call normally:</div><pre>user.name</pre><pre>user.age<br><br></pre><p></p></div><div><h5><strong>Example run</strong></h5></div><div>Below we see how the program works.</div><div><img src="data/kuva%20%283%29.png" alt="" role="presentation" class="img-fluid"><br></div><div><br></div><div>We render the page's form to the /form-route, send the data to the /submit-route, and when we send the data, we get to another page.</div><div><img src="data/kuva%20%284%29.png" alt="" role="presentation" class="img-fluid"><br></div><div><br></div><div><br></div><br><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15283"></a><h2>3. POST-request and Postman tool</h2><h4 dir="ltr">What is Postman?</h4>Postman is a free API tool that lets you, for example, test HTTP routes, send data to these routes and see what you get in response.<br>Since POST routes require data inside the body, just using a browser doesn't give us an easy way to test our POST routes.<div><br></div>You can find Postman's user manual <a href="https://learning.postman.com/docs/introduction/overview/">here</a>.<br>You can find the Postman Agent installation link <a href="https://www.postman.com/downloads/postman-agent/">here</a>. Postman Agent works in such a way that you can send and receive requests when Postman Agent is installed and you have created an account in Postman.<div><br></div><div>Testing your routes through a service like Postman is not mandatory, but it makes your programming tasks easier.</div><div><br></div><div><br></div><h4>How can I do a POST request?</h4>Below we see a picture where a POST request is sent via a new request to the address localhost:8000/math/doubling.<br>We have chosen the data type of the body to be raw so that we can send the text as it is. In our example, we send the value 5, in text format.<br>Below we see the response code, 200, as well as the text response:<div><br></div><pre>Doubled value: 10<br><br><em><strong></strong></em></pre><div><strong><img src="data/kuva%20%282%29.png" alt="" role="presentation" class="img-fluid"><br></strong></div><div><strong><br></strong></div><div><strong><br></strong></div><div>Below we see the code we used to get the above post-route done.</div><div><br></div><div><div><pre>#[macro_use] extern crate rocket;<br>#[post("/doubling", data = "&lt;number&gt;")]<br><span class="" style="color: rgb(125, 159, 211);">fn </span>double_number(number: String) -&gt; String {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>number.trim().parse::&lt;i32&gt;() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok(value) =&gt; format!("Doubled value: {}", value * 2),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err(_) =&gt; String::from("Give a proper float value!"),<br>&nbsp;&nbsp;&nbsp; }<br>}<br>#[launch]<br><span class="" style="color: rgb(125, 159, 211);">fn </span>rocket() -&gt; _ {<br>&nbsp;&nbsp;&nbsp; rocket::build().mount("/math", routes![double_number])<br>}</pre><br></div>We send the data in somewhat the same style inside the #[post] macro as in the #[get] macro, but we don't define the parameter inside the url address, we give it separately.<strong></strong></div></div><a href="#toc">&uarr; top</a>
</body>
</html>