<!doctype html>
<html>
<head>
    <title>1_Komentorivin käyttö ja Threadsit</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Komentorivin käyttö ja Threadsit</h1><p class="book_summary"></p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Komentorivin käyttö ja Threadsit" class="font-weight-bold text-decoration-none" href="#ch15266">1. Komentorivin käyttö ja Threadsit</a></li><li><a title="2. Komentoriviargumentit" class="font-weight-bold text-decoration-none" href="#ch15267">2. Komentoriviargumentit</a></li><li><a title="3. Säikeet / Threadsit" class="font-weight-bold text-decoration-none" href="#ch15268">3. Säikeet / Threadsit</a><ul><li><a title="3.1. Säikeiden välinen kommunikointi" class="text-decoration-none" href="#ch15270">3.1. Säikeiden välinen kommunikointi</a></li></ul></li><li><a title="4. sleep-komento ja time-moduuli" class="font-weight-bold text-decoration-none" href="#ch15269">4. sleep-komento ja time-moduuli</a></li></ul></div><div class="book_chapter"><a name="ch15266"></a><h2>1. Komentorivin käyttö ja Threadsit</h2>Tässä luvussa käymme läpi komentoriviargumenttien käytön, threadsit, ja tiedon antamisen toiselle threadille.<br></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15267"></a><h2>2. Komentoriviargumentit</h2><h4 dir="ltr" style="text-align: left;">Komentoriviargumentit</h4><div><p>Komentoriviargumentteja voidaan käsitellä käyttämällä standardikirjaston std::env::args() -funktiota. Tämä funktio palauttaa iteroinnin komentoriviargumenttien yli, joissa ensimmäinen argumentti on ohjelman nimi.</p><p>Alla on esimerkki, jossa käsitellään kolme argumenttia: merkkijono (String), kokonaisluku (i32) ja liukuluku (f64). Ohjelma tulostaa argumenttien määrän, itse argumentit ja tarkistaa oikeellisuuden.</p><p>Hyödynnämme <a href="https://doc.rust-lang.org/std/env/fn.args.html">args()</a>-funktiota, joka palauttaa <a href="https://doc.rust-lang.org/std/env/struct.Args.html">Args</a>-structin, joka taas sisältää jokaisen käyttäjän antaman argumentin String-tyyppinä structin sisällä. Käyttämämme funktio <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">collect()</a> kerää ohjelman argumentit Vectoriin, joka on tyyppiä String. Yritämme muuttaa int ja float tyypit String muodosta takaisin numeroiksi, jonka jälkeen tulostamme käyttäjän antamat arvot, jos parsiminen onnistui.</p><pre>use std::env;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Kerätään kaikki komentoriviargumentit vektoriin<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>args: Vec&lt;<span class="" style="color: rgb(125, 159, 211);">String</span>&gt; = env::args().collect();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>args.len() != 4 {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Odottamaton määrä argumentteja! Käytä seuraavasti:");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("cargo run &lt;string&gt; &lt;integer&gt; &lt;float&gt;");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Otetaan argumentit talteen ja muunnetaan tarvittaviin tyyppeihin<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>string_arg = &amp;args[1];<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>int_arg: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= <span class="" style="color: rgb(125, 159, 211);">match </span>args[2].parse() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok(n) =&gt; n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err(_) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Virheellinen kokonaisluku argumentti: {}", args[2]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>float_arg: <span class="" style="color: rgb(125, 159, 211);">f64 </span>= <span class="" style="color: rgb(125, 159, 211);">match </span>args[3].parse() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok(n) =&gt; n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err(_) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Virheellinen liukuluku argumentti: {}", args[3]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; // Tulostetaan argumenttien tiedot<br>&nbsp;&nbsp;&nbsp; println!("Argumenttien määrä: {}", args.len() - 1); // -1 koska args[0] on ohjelman nimi ja täten lisää yhden argumenttilistan pituuteen<br>&nbsp;&nbsp;&nbsp; println!("Argumentti 1 (string): {}", string_arg);<br>&nbsp;&nbsp;&nbsp; println!("Argumentti 2 (integer): {}", int_arg);<br>&nbsp;&nbsp;&nbsp; println!("Argumentti 3 (float): {}", float_arg);<br>}</pre></div><div>Ohjelman ajo:</div><pre>cargo run Terve 5 6.2<br></pre><div><br></div><div>Ohjelman tulostus:<br></div><pre>Argumenttien määrä: 3<br>Argumentti 1 (string): Terve<br>Argumentti 2 (integer): 5&nbsp; &nbsp;<br>Argumentti 3 (float): 6.2 <br></pre></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15268"></a><h2>3. Säikeet / Threadsit</h2><h4>Threadsit (Säikeet)</h4><div><br></div><h4><strong>Mikä on säie?<br></strong></h4><div><span><span><span>Säie (thread) on rinnakkaisohjelmoinnin perusyksikkö, joka mahdollistaa ohjelman suorittamisen useissa rinnakkaisissa poluissa. Säikeet jakavat saman prosessin resurssit, kuten muistin ja tiedostokahvat, mutta toimivat itsenäisesti ja voivat suorittaa tehtäviä samanaikaisesti.<br><br>Rustissa säikeet ovat keskeinen osa kielessä vahvasti tuettua rinnakkaisohjelmointia. Rust käyttää tehokasta muistinhallintaa ja omistajuusmallia, joka varmistaa, että säikeet voivat toimia turvallisesti ilman perinteisiä data-ajoitusongelmia, kuten race condition -tilanteita. Rustin standardikirjasto (std::thread) tarjoaa korkean tason työkaluja säikeiden luomiseen ja hallintaan.<br><br>Rustin säikeet hyödyntävät perinteisten säiemekanismien lisäksi turvallisuusmekanismeja, kuten synkronointityökaluja (Mutex, Arc). Tämä tekee mahdolliseksi turvallisen tietojen jaon säikeiden välillä ilman tarpeetonta suorituskykyheikennystä. Rust suosii turvallista rinnakkaisuutta ilman manuaalista lukkojen hallintaa, mikä auttaa ohjelmoijia kirjoittamaan tehokasta ja luotettavaa koodia monisäikeisessä ympäristössä.</span></span><span><span><br></span></span></span></div><div><span><span><span><br></span></span></span></div><div><span><span><span><strong>Esimerkki</strong></span></span></span></div><div><span><span><span><span><span>Alla on yksinkertainen esimerkki Rust-säikeestä, joka laskee summan ja palauttaa tuloksen pääohjelmalle. <br></span></span></span></span></span></div><div><span><span><span><span><span>Luomme uuden säikeen <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html">spawn</a>-funktiolla.<br></span></span></span></span></span></div><div><span><span><span><span><span>Käytämme <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join">join</a>-funktiota odottaaksemme threadin valmistumista, jonka jälkeen pääohjelman suoritus jatkuu. </span></span></span></span></span><span><span><span><span><span>Tallennamme threadin palauttaman tuloksen result-muuttujaan ja tulostamme tuloksen.<br></span></span></span></span></span></div><div><span><span><span><span><span><br></span></span></span></span></span></div><pre><span><span><span><span><span>use std::thread;</span></span></span></span></span></pre><div><pre><span><span><span><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; // Luodaan säie, joka laskee summan</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>handle = <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(|| {</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>sum = 5 + 11;</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Säikeen laskema summa: {}", sum);</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum // Palautetaan summa säikeestä</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; });</span></span></span></span></span><br><span><span><span><span><span></span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; // Odotetaan säikeen valmistumista ja saadaan tulos</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>result = handle.join().expect("Säie epäonnistui");</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp; &nbsp;</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; // Tulostetaan pääohjelmassa tulos</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; println!("Pääohjelma vastaanotti summan: {}", result);</span></span></span></span></span><br><span><span><span><span><span>}</span></span></span></span></span><br><span><span><span><span><span></span></span></span></span></span></pre><span><span><span><span><span>Ohjelma tulostaa:</span></span></span></span></span></div><pre>Säikeen laskema summa: 16<br>Pääohjelma vastaanotti summan: 16<br><br></pre><h5><strong><strong>Closure - </strong>Thread-spawnin käyttämä syntaksi ylläolevassa esimerkissä</strong><br><strong></strong></h5><span>Koska säikeemme ei käytä mitään erillistä funktiota, voimme luoda thread-spawn komennon sisälle oman "anonyymin" funktion, jolla ei ole nimeä, mutta jonka sisältö suoritetaan.<br><ul><li><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closure</a> <strong>( | | { ... } )</strong> määrittää koodin, joka suoritetaan uudessa säikeessä.</li><li><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closuremme </a>ei ota tässä tapauksessa parametreja, joten käytetään tyhjää putkimerkkiä<strong> | |</strong>.</li><li>Putkimerkin saa tehtyä painamalla Alt + &lt;&gt;, Z kirjaimen vasemmalla puolella olevaa näppäintä.<br></li></ul><br></span><h5><span><strong>Prosessin lopettaminen säikeessä</strong></span><br><span><strong></strong></span></h5><span>Säie voi lopettaa prosessin käyttäen standardikirjaston <a href="https://doc.rust-lang.org/std/process/fn.exit.html">exit-komentoa</a>.<br><br><strong>Esimerkki</strong><br>Esimerkkiohjelmassa on funktio, jota luomamme säie kutsuu. Tämä funktio on tauolla 3 sekuntia, jonka jälkeen se tulostaa tekstiä, ja lopettaa ohjelman exit-komentoa käyttäen. Käyttäjän on pyrittävä ennen säiettä kirjoittamaan saman teksti - success - jotta ohjelma loppuu ja käyttäjä "voittaa" pelin.<br><br><div><div></div></div></span><pre><span><p data-pm-slice="0 0 []">use std::thread;
</p><p>use std::time::Duration;
</p><p>use std::io::{self, Write};

</p><p><span class="" style="color: rgb(125, 159, 211);">fn </span>thread_message() {
</p><p>    <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(3)); // Säie odottaa 3 sekuntia
</p><p>    println!("Thread: onnistuin!");
</p><p>    std::process::exit(0);
</p><p>}
</p><p>
</p><p><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
</p><p>    println!("Kirjoita 'onnistuin' ennen kuin säie kirjoittaa ennen sinua!");</p><p>
</p><p>    // Käynnistetään säie
</p><p>    <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(|| {
</p><p>        thread_message();
</p><p>    });</p><p>
</p><p>    // Käyttäjän syöte
</p><p>    <span class="" style="color: rgb(239, 69, 64);">io</span>::stdout().flush().unwrap();
</p><p>    <span class="" style="color: rgb(125, 159, 211);">let mut </span>user_input = String::new();
</p><p>    io::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>user_input).expect("Failed to read input");</p><p>
</p><p>    <span class="" style="color: rgb(125, 159, 211);">match </span>user_input.trim() {
</p><p>        "success" =&gt; println!("Sinä onnistuit ensin!"),
</p><p>        _   =&gt; {
</p><p>            println!("Voi ei! Kirjoitit väärin..."");
</p><p>            <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(3));
</p><p>        }
</p><p>    }
</p><p>}
</p></span></pre><span>Ohjelman ajo, käyttäjä ei syötä mitään:<br></span><pre>Kirjoita 'onnistuin' ennen kuin säie kirjoittaa ennen sinua!<br><span>Thread: onnistuin!<br><br></span><span></span></pre><span>Ohjelman ajo, käyttäjä kirjoittaa success:<br></span><pre><span>Kirjoita 'onnistuin' ennen kuin säie kirjoittaa ennen sinua!</span><br><span><strong>onnistuin</strong></span><br><span>Sinä onnistuit ensin!<br><br></span></pre><p><span>Ohjelman ajo, käyttäjä kirjoittaa väärän tekstin:</span><br><span></span></p><pre><span>Kirjoita 'onnistuin' ennen kuin säie kirjoittaa ennen sinua!<br><strong>oh no</strong><br>Voi ei! Kirjoitit väärin...<br>Thread: onnistuin!<strong></strong><br><br><br></span></pre><span><strong></strong><strong></strong></span><strong></strong></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15270"></a><h3>3.1. Säikeiden välinen kommunikointi</h3><p dir="ltr" style="text-align: left;"></p><h4><span>Säikeiden välinen kommunikointi</span></h4><div><p>Rustissa säikeiden välinen kommunikointi on tehokasta ja turvallista pääasiassa kahdella tavalla: <strong>viestinvälityskanavilla (mpsc)</strong> ja <strong>jaetuilla muistinrakenteilla</strong>.
 Rust suosii viestipohjaista lähestymistapaa, koska se helpottaa datan 
synkronointia ja estää kilpailutilanteita (race conditions).</p><p><br></p><h4><strong>Viestinvälityskanavat (mpsc)</strong></h4><p>Rust tarjoaa <a href="https://doc.rust-lang.org/std/sync/mpsc/">std::sync::mpsc</a>
 (multiple producer, single consumer) -moduulin, joka mahdollistaa datan
 siirron säikeiden välillä. Kanavat koostuvat kahdesta osasta:</p><ol><li><strong>Lähetin (Sender)</strong>: Säie voi lähettää viestejä kanavan kautta toiselle säikeelle.</li><li><strong>Vastaanotin (Receiver)</strong>: Vastaanottaja odottaa saapuvia viestejä ja käsittelee ne.</li></ol><p>Kanavat
 takaavat turvallisen kommunikoinnin ilman jaetun muistin käsittelyä. 
Kun säie lähettää datan kanavan kautta, omistajuus siirtyy, eikä 
alkuperäinen säie voi enää käyttää kyseistä dataa.</p><p><br></p><h4><strong>Jaettu muisti</strong></h4><p>Vaihtoehtoisesti säikeet voivat käyttää jaettuja muistirakenteita, kuten Arc ja Mutex.&nbsp;</p><ul><li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>(Atomic Reference Counter) mahdollistaa tietorakenteen jaon useiden säikeiden kesken.&nbsp;</li><li><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex </a>(Mutual Exclusion) estää useita säikeitä pääsemästä dataan samanaikaisesti ja tarjoaa turvallisen lukituksen tietoon.</li></ul><div><br></div><div><strong>Esimerkki kanavien käytöstä</strong></div><div>Alla on esimerkkiohjelma, jossa säikeet kommunikoivat saman kanavan kautta.</div><div><pre>use std::sync::mpsc;<br>use std::thread;<br>use std::time::Duration;<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Luodaan kanava tiedonvaihtoon säikeiden kanssa<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>(tx, rx) = <span class="" style="color: rgb(239, 69, 64);">mpsc</span>::channel();<br><br>&nbsp;&nbsp;&nbsp; // Säie 1: Viesti joka sekunti<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx1 = tx.clone();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(1));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx1.send("Thread 1: Lähetetään viesti 1 sekunnin välein").unwrap();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; // Säie 2: Viesti kahden sekunnin välein<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx2 = tx.clone();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(2));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx2.send("Thread 2: Lähetetään viesti 2 sekunnin välein").unwrap();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; // Säie 3: Viesti viiden sekunnin välein<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx3 = tx.clone();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(5));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx3.send("Thread 3: Lähetetään viesti 5 sekunnin välein").unwrap();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; // Vastaanotetaan viestejä kanavasta ja tulostetaan konsoliin<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>received_message <span class="" style="color: rgb(125, 159, 211);">in </span>rx {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("{received_message}");<br>&nbsp;&nbsp;&nbsp; }<br>}</pre></div></div><div><span><span><span>Säikeet
 kloonaavat lähettimen käytettäväkseen. Ne pyörivät jatkuvasti, ja aina 
kun ne lähettävät kloonatulla lähettimellä viestin, printtaa luomamme 
for-looppi aina uuden viestin tullessa komentokehotteeseen saamamme 
viestin. Ohjelma pyörii loputtomasti, kunnes itse lopetamme 
suorittamisen esimerkiksi CTRL + C -näppäinkomennolla.<br></span></span></span><strong><span><span></span></span></strong></div><br><h4>Numeroarvojen yhteinen käyttö</h4>Säikeet voivat käyttää yhteisiä numeroarvoja kanavien kautta. Alla olevassa esimerkkiohjelmassa kaksi säiettä muokkaa samaa arvoa kloonatun kanavan kautta. Ne lähettävät numeroarvoja. Pääsäie käsittelee viestit for loopissa, joka loppuu vasta, kun arvojen antaminen on säikeissä loppunut. Alustamme pääsäikeessä arvon nollaan. Pääsäie lisää arvoon yhden jokaisen viestin kohdalla. Muut säikeet lisäävät -100, ja +200. Lopputulos on siis -100 + 1 + 200 + 1 = 102.<br>Käytämme <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.drop">drop</a>-komentoa pääsäikeen kopion sulkemiseen, jotta rx "tietää", että lisää viestejä ei ole tulossa.<br><br>Esimerkkiohjelma:<div><pre>use std::sync::mpsc;</pre><pre>use std::thread;</pre><pre>use std::time::Duration;</pre><pre><br></pre><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</pre><pre>&nbsp; &nbsp; // Luodaan kanava (lähetin ja vastaanotin)</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>(tx, rx) = <span class="" style="color: rgb(239, 69, 64);">mpsc</span>::channel();</pre><pre><br></pre><pre>&nbsp; &nbsp; // Alkuarvo</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> summa = 0;</pre><pre><br></pre><pre>&nbsp; &nbsp; // Kopioidaan lähetin molemmille säikeille</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx1 = tx.clone();</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx2 = tx.clone();</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_millis(500)); // Odotetaan 500 ms</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; tx1.send(-100).unwrap();</pre><pre>&nbsp; &nbsp; });</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_millis(700)); // Odotetaan 700 ms</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; tx2.send(200).unwrap();</pre><pre>&nbsp; &nbsp; });</pre><pre><br></pre><pre>&nbsp; &nbsp; // Pääsäie vastaanottaa ja käsittelee viestit, kunnes kaikki lähettäjät ovat valmiita</pre><pre>&nbsp; &nbsp; drop(tx); // Suljetaan pääsäikeen kopio lähettimestä, jotta `rx` tietää, ettei tule lisää viestejä</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>arvo <span class="" style="color: rgb(125, 159, 211);">in </span>rx {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; // Tämä iteroi automaattisesti kaikki viestit</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; summa += arvo; // Lisätään vastaanotettu arvo</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; summa += 1; // Pääsäikeen oma lisäys</pre><pre>&nbsp; &nbsp; }</pre><pre><br></pre><pre>&nbsp; &nbsp; // Tulostetaan lopputulos</pre><pre>&nbsp; &nbsp; println!("Lopullinen summa: {}", summa);</pre><pre>}<br><br></pre><strong>Esimerkkiajo:</strong></div><pre>Lopullinen summa: 102</pre><p><br></p><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15269"></a><h2>4. sleep-komento ja time-moduuli</h2><h4>Sleep-komento Rustissa</h4><p><a href="https://doc.rust-lang.org/std/thread/fn.sleep.html">sleep</a>-komento viivyttää seuraavia komentoja sille annetun ajan verran. Se ottaa parametrikseen <a href="https://doc.rust-lang.org/std/time/struct.Duration.html">Duration</a>-tyypin, eikä numeroarvoja suoraan. Duration tarjoaa eri metodeita eri aikamittojen antamiseksi kuten <a href="https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs">from_secs()</a> jolle annetaan haluttu sekuntimäärä positiivisena kokonaislukuna.</p><p>Käytimme sleep-komentoa aikaisemmassa säie-esimerkissämme jo aiemmin, mutta alla on uusi esimerkki miten voimme hyödyntää eri aikavälein ajavia säikeitä viivyttämällä ohjelman toimintaa sleep-komentoa käyttämällä.</p><pre>use std::thread;<br>use std::time::Duration;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>handle = <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(|| {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Käynnistetään toinen säie...");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(3)); // Nukkuu 3 sekuntia<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Toinen säie heräsi!");<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; println!("Pääsäie jatkaa...");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(1)); // Nukkuu 1 sekunnin<br>&nbsp;&nbsp;&nbsp; println!("Pääsäie on hereillä!");<br>&nbsp;&nbsp;&nbsp; handle.join().unwrap(); // Odotetaan, että toinen säie päättyy<br>&nbsp;&nbsp;&nbsp; println!("Kaikki säikeet päättyivät!");<br>}</pre><pre>Ohjelman ajo:<br>Pääsäie jatkaa...<br>Käynnistetään toinen säie...<br>Pääsäie on hereillä!<br>Toinen säie heräsi!<br>Kaikki säikeet päättyivät!<br><br></pre><p>Ohjelma luo ensin toisen säikeen. Tämän jälkeen pääsäie tulostaa "Pääsäie jatkaa...", jonka jälkeen se odottaa sekunnin. Tämän jälkeen pääsäie taas tulostaa tekstiä, jonka jälkeen se odottaa kunnes toinen säie on valmis.</p><p>Toinen säie tulostaa Käynnistyslauseen, odotaa kolme sekuntia, ja tulostaa taas tekstiä. Kun kaikki muut on tehty, tulostaa pääsäie vielä kaikkien säikeiden päättyneen.</p><p>Vaikka toinen säie luodaan ennen pääsäikeen tulostusta, vie säikeen luonti enemmän aikaa kuin tulostus, jonka takia pääsäie ehti tulostamaan ensimmäisen lauseensa ennen toista säiettä.</p><p><br></p><h4>time-moduuli</h4><div><p data-start="27" data-end="224">Rustin std::time-moduuli tarjoaa työkaluja ajan mittaamiseen, ajanjaksojen esittämiseen ja nykyisen ajan käsittelyyn. Se sisältää useamman tyypin joilla on eri käyttötarkoituksia. Yllä käytimme jo Duration-tyyppiä sleep-komennossa. Muita tyyppejä joita time-moduuli tarjoaa ovat esimerkiksi Instant ja SystemTime.</p><p data-start="27" data-end="224"><br></p><h5>Instant</h5><div><a href="https://doc.rust-lang.org/std/time/struct.Instant.html">std::time::Instant</a> edustaa tarkkaa hetkeä ohjelman suorituksessa, ja sitä käytetään pääasiassa suorituskyvyn mittaamiseen. Se ei ole sidottu järjestelmän kellonaikaan, vaan mittaa vain kulunutta aikaa suhteessa toiseen Instant-arvoon.</div><div><br></div><div><pre>use std::time::Instant;<br><br><span class="" style="color: rgb(125, 159, 211);">let </span>start = Instant::now();<br>// Suorita jotain laskentaa...<br><span class="" style="color: rgb(125, 159, 211);">let </span>elapsed = start.elapsed(); // Mittauksen kesto<br>println!("Koodi suoritettiin {:?} sekunnissa", elapsed);<br><br></pre><p><code><span class="" style="color: rgb(51, 51, 51);"></span></code>Instant arvoja voi vertailla keskenään ja niillä voi laskea Duration-tyypin arvoja.</p><pre><code><br><span class="" style="color: rgb(125, 159, 211);">let </span>later = start + Duration::from_secs(10); // 10 sekuntia myöhemmin<br><br></code></pre></div><h5>SystemTime</h5><p><a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html">std::time::SystemTime</a> edustaa absoluuttista kellonaikaa, joka perustuu järjestelmän kelloon. Se voi muuttua esimerkiksi, jos käyttäjä muuttaa aikaa.</p><p><br></p><p></p><h4 data-start="1909" data-end="1928">Huomioitavaa</h4>
<ul data-start="1929" data-end="2186">
<li data-start="1929" data-end="1969">Aika (Duration) ei voi olla negatiivinen.</li>
<li data-start="1970" data-end="2034">Instant tyyppiä ei voi suoraan muuntaa SystemTime-arvoksi</li>
<li data-start="2035" data-end="2186">std::time ei tarjoa suoraan ajastimia (timers), vaan niiden toteuttaminen vaatii muita työkaluja, kuten käyttämämme std::thread::sleep()</li></ul><p></p></div></div><a href="#toc">&uarr; top</a>
</body>
</html>