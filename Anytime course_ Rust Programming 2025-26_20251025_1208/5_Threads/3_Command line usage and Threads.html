<!doctype html>
<html>
<head>
    <title>3_Command line usage and Threads</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Command line usage and Threads</h1><p class="book_summary"></p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Komentorivin käyttö ja Threadsit" class="font-weight-bold text-decoration-none" href="#ch15271">1. Komentorivin käyttö ja Threadsit</a></li><li><a title="2. Command line arguments" class="font-weight-bold text-decoration-none" href="#ch15272">2. Command line arguments</a></li><li><a title="3. Threads" class="font-weight-bold text-decoration-none" href="#ch15273">3. Threads</a><ul><li><a title="3.1. Communication between threads" class="text-decoration-none" href="#ch15275">3.1. Communication between threads</a></li></ul></li><li><a title="4. sleep-command and time-module" class="font-weight-bold text-decoration-none" href="#ch15274">4. sleep-command and time-module</a></li></ul></div><div class="book_chapter"><a name="ch15271"></a><h2>1. Komentorivin käyttö ja Threadsit</h2>In this chapter we go through the use of command line arguments, threads, and passing information to another thread.</div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15272"></a><h2>2. Command line arguments</h2><h4 dir="ltr" style="text-align: left;">Command line arguments</h4><div>Command line arguments can be handled using the standard library's std::env::args() function. This function returns an iteration over the command line arguments, where the first argument is the name of the program.<br><br>Below is an example that handles three arguments: a string (String), an integer (i32), and a float (f64). The program prints the number of arguments, the arguments themselves and checks the correctness.<br><br>We use the <a href="https://doc.rust-lang.org/std/env/fn.args.html">args()</a> function, which returns an <a href="https://doc.rust-lang.org/std/env/struct.Args.html">Args</a> struct, which in turn contains each argument given by the user as a String type inside the struct. The function <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">collect()</a> collects the program's command line arguments into a Vector, which is of type String. We try to change the int and float types from String back to numbers, after which we print the values ​​given by the user if the parsing was successful.<pre>use std::env;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Let's collect all command line arguments into a vector<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>args: Vec&lt;<span class="" style="color: rgb(125, 159, 211);">String</span>&gt; = env::args().collect();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>args.len() != 4 {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Unexpected number of arguments! Use as follows:");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("cargo run &lt;string&gt; &lt;integer&gt; &lt;float&gt;");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; // Let's collect the arguments and convert them to the necessary types<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>string_arg = &amp;args[1];<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>int_arg: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= <span class="" style="color: rgb(125, 159, 211);">match </span>args[2].parse() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok(n) =&gt; n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err(_) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Invalid integer argument: {}", args[2]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>float_arg: <span class="" style="color: rgb(125, 159, 211);">f64 </span>= <span class="" style="color: rgb(125, 159, 211);">match </span>args[3].parse() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok(n) =&gt; n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err(_) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Invalid float argument: {}", args[3]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp; // Print the given converted and parsed arguments<br>&nbsp;&nbsp;&nbsp; println!("Argument count: {}", args.len() - 1); // -1 because args[0] is the name of the program and thus adds one to the length of the argument list<br>&nbsp;&nbsp;&nbsp; println!("Argument 1 (string): {}", string_arg);<br>&nbsp;&nbsp;&nbsp; println!("Argument 2 (integer): {}", int_arg);<br>&nbsp;&nbsp;&nbsp; println!("Argument 3 (float): {}", float_arg);<br>}</pre></div><div>Example run:</div><pre>cargo run hello 5 6.2<br></pre><div><br></div><div>Example output:</div><pre>Argument count: 3<br>Argument (string): hello<br>Argument 2 (integer): 5&nbsp; &nbsp;<br>Argument 3 (float): 6.2 <br></pre></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15273"></a><h2>3. Threads</h2><h4>Threads</h4><div><br></div><h4><strong>What is a thread</strong></h4><div><span><span><span>A thread is the basic unit of parallel programming, which allows the execution of a program in several parallel paths. Threads share the resources of the same process, such as memory and file handles, but operate independently and can perform tasks simultaneously.<br><br>In Rust, threads are a key part of parallel programming, which is strongly supported in the language. Rust uses efficient memory management and an ownership model that ensures that threads can run safely without traditional data timing problems such as race conditions. Rust's standard library (std::thread) provides high-level tools for creating and managing threads.<br><br>In addition to traditional thread mechanisms, Rust's threads utilize safety mechanisms such as synchronization tools (Mutex, Arc). This enables safe data sharing between threads without unnecessary performance degradation. Rust favors safe concurrency without manual lock management, which helps programmers write efficient and reliable code in a multithreaded environment.</span></span><span><span><br></span></span></span></div><div><span><span><span><br></span></span></span></div><div><strong>Example</strong></div>Below is a simple example of a Rust thread that calculates a sum and returns the result to the main program.<br>We create a new thread with the <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html">spawn</a> function.<br>We use the <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join">join</a> function to wait for the thread to finish, after which the execution of the main program continues. We save the result returned by the thread in the result variable and print the result.<div><span><span><span><span><span><br></span></span></span></span></span></div><pre><span><span><span><span><span>use std::thread;</span></span></span></span></span></pre><div><pre><span><span><span><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; // Generate a thread that counts the sum</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>handle = <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(|| {</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>sum = 5 + 11;</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Sum counted by the thread: {}", sum);</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum // Return the sum from the thread</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; });</span></span></span></span></span><br><span><span><span><span><span></span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; // We wait for the thread to finish and get the result</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>result = handle.join().expect("Thread failed");</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp; &nbsp;</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; // Print the output in the main program also</span></span></span></span></span><br><span><span><span><span><span>&nbsp;&nbsp;&nbsp; println!("Main program received the sum: {}", result);</span></span></span></span></span><br><span><span><span><span><span>}</span></span></span></span></span><br><span><span><span><span><span></span></span></span></span></span></pre><span><span><span><span><span>Program prints:</span></span></span></span></span></div><pre>Sum counted by the thread: 16<br>Main program received the sum: 16<br><br></pre><h5><strong><strong>Closure - The syntax used by spawn functin in the example above</strong></strong><strong></strong></h5><span>Since our thread does not use any separate function, we can create our own "anonymous" function inside the thread-spawn command, which does not have a name, but whose content is executed.</span><ul><li><span><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closure</a><strong> ( | | { ... } )</strong> specifies code to be executed in a new thread.</span></li><li><span><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Our closure</a> takes no parameters in this case, so the empty pipe symbol <strong>| |</strong> is used.</span></li><li><span>The pipe symbol can be made by pressing Alt + &lt;&gt;, the key to the left of the letter Z in the nordic keyboard.</span></li></ul><div><br></div><h5><span><strong>Terminating a process in a thread</strong></span><span><strong></strong></span></h5><span>A thread can terminate the process using the <a href="https://doc.rust-lang.org/std/process/fn.exit.html">exit</a> command of the standard library.<br><br><strong>Example</strong><br>The example program has a function that is called by the thread we created. This function pauses for 3 seconds, after which it prints text, and terminates the program using the exit command. The user must try to write the same text - success - before the thread so that the program ends and the user "wins" the game.<br><br><div><div></div></div></span><pre><span><p data-pm-slice="0 0 []">use std::thread;
</p><p>use std::time::Duration;
</p><p>use std::io::{self, Write};

</p><p><span class="" style="color: rgb(125, 159, 211);">fn </span>thread_message() {
</p><p>    <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(3)); // Thread waits 3 seconds</p><p>    println!("Thread: success!");
</p><p>    std::process::exit(0);
</p><p>}
</p><p>
</p><p><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
</p><p>    println!("Type 'success' before the thread prints it!");</p><p>
</p><p>    // Start the thread</p><p>    <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(|| {
</p><p>        thread_message();
</p><p>    });</p><p>
</p><p>    // User input</p><p>    <span class="" style="color: rgb(239, 69, 64);">io</span>::stdout().flush().unwrap();
</p><p>    <span class="" style="color: rgb(125, 159, 211);">let mut </span>user_input = String::new();
</p><p>    io::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>user_input).expect("Failed to read input");</p><p>
</p><p>    <span class="" style="color: rgb(125, 159, 211);">match </span>user_input.trim() {
</p><p>        "success" =&gt; println!("You succeeded first!"),
</p><p>        _   =&gt; {
</p><p>            println!("Oh no! You mistyped...");
</p><p>            <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(3));
</p><p>        }
</p><p>    }
</p><p>}
</p></span></pre><span>Example run, user does not input anything:</span><pre><span>Type 'success' before the thread prints it!</span><br><span>Thread: success!<br><br></span><span></span></pre><span>Example run: user inputs "success":</span><pre><span>Type 'success' before the thread prints it!</span><br><span><strong>success</strong></span><br><span>You succeeded first<br><br></span></pre><p><span>Example run: user inputs wrong text "oh no":</span><span></span></p><pre><span>Type 'success' before the thread prints it!<br><strong>oh no</strong><br>Oh no! You mistyped...<br>Thread: success!<strong></strong><br><br><br></span></pre><span><strong></strong><strong></strong></span><strong></strong></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15275"></a><h3>3.1. Communication between threads</h3><p dir="ltr" style="text-align: left;"></p><h4><span>Interthread communication</span></h4><div>In Rust, communication between threads is efficient and safe mainly in two ways: <strong>message passing channels (mpsc)</strong> and <strong>shared memory structures</strong>. Rust prefers a message-based approach because it facilitates data synchronization and prevents race conditions.</div><div><br><h4><strong>Message passing channels (mpsc)</strong></h4>Rust provides a <a href="https://doc.rust-lang.org/std/sync/mpsc/">std::sync::mpsc</a> (multiple producer, single consumer) module that enables data transfer between threads. Channels consist of two parts:<br><br><ul><li><strong>Sender</strong>: A thread can send messages through a channel to another thread.</li><li><strong>Receiver</strong>: The receiver waits for incoming messages and processes them.</li></ul>Channels guarantee secure communication without dealing with shared memory. When a thread sends data over a channel, ownership is transferred and the original thread can no longer access that data.<p><br></p><h4><strong>Shared memory</strong></h4>Alternatively, threads can use shared memory structures such as Arc and Mutex. <br><br><ul><li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a> (Atomic Reference Counter) allows the data structure to be shared between several threads. </li><li><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex</a> (Mutual Exclusion) prevents multiple threads from accessing data at the same time and provides a secure lock on the data.</li></ul><div><br></div><div><strong>Example of using channels</strong></div><div>Below is an example program where threads communicate over the same channel.</div><div><pre>use std::sync::mpsc;<br>use std::thread;<br>use std::time::Duration;<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Let's create a channel for data exchange with threads<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>(tx, rx) = <span class="" style="color: rgb(239, 69, 64);">mpsc</span>::channel();<br><br>&nbsp;&nbsp;&nbsp; // Thread 1: A message every second<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx1 = tx.clone();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(1));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx1.send("Thread 1: Sending message every 1 second").unwrap();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; // Thread 2: Message every two seconds<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx2 = tx.clone();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(2));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx2.send("Thread 2: Sending message every 2 seconds").unwrap();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; // Thread 3: Message every five seconds<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tx3 = tx.clone();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(move || {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(5));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx3.send("Thread 3: Sending message every 5 seconds").unwrap();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; });<br><br>&nbsp;&nbsp;&nbsp; // We receive messages from the channel and print them to the console<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">for </span>received_message <span class="" style="color: rgb(125, 159, 211);">in </span>rx {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("{received_message}");<br>&nbsp;&nbsp;&nbsp; }<br>}</pre></div></div><div><span><span><span>Threads clone the transmitter to use. They run continuously, and every time they send a message with the cloned transmitter, the for-loop we created prints the message we received at the command prompt every time a new message arrives. The program runs endlessly until we ourselves stop the execution with, for example, the CTRL + C key command.</span></span></span><strong><span><span></span></span></strong></div><br><h4>Common use of numeric values</h4>Threads can access common numeric values ​​through channels. In the example program below, two threads modify the same value via a cloned channel. They send numerical values. The main thread processes the messages in a for loop, which ends only when the threads have finished assigning values. We initialize the value to zero in the main thread. The main thread adds one to the value for each message. Other threads add -100, and +200. So the final result is -100 + 1 + 200 + 1 = 102.<br>We use the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.drop">drop</a> command to close the copy of the main thread so that the rx "knows" that no more messages are coming.<br><br>Example program:<div><pre>use std::sync::mpsc;</pre><pre>use std::thread;</pre><pre>use std::time::Duration;</pre><pre><br></pre><pre>fn main() {</pre><pre>&nbsp; &nbsp; // Creating a channel (transmitter and receiver)</pre><pre>&nbsp; &nbsp; let (tx, rx) = mpsc::channel();</pre><pre><br></pre><pre>&nbsp; &nbsp; // Initial value</pre><pre>&nbsp; &nbsp; let mut total_sum = 0;</pre><pre><br></pre><pre>&nbsp; &nbsp; // Let's copy the sender to both threads</pre><pre>&nbsp; &nbsp; let tx1 = tx.clone();</pre><pre>&nbsp; &nbsp; let tx2 = tx.clone();</pre><pre><br></pre><pre>&nbsp; &nbsp; thread::spawn(move || {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; thread::sleep(Duration::from_millis(500)); // Wait 500 ms</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; tx1.send(-100).unwrap();</pre><pre>&nbsp; &nbsp; });</pre><pre><br></pre><pre>&nbsp; &nbsp; thread::spawn(move || {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; thread::sleep(Duration::from_millis(700)); // Wait 700 ms</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; tx2.send(200).unwrap();</pre><pre>&nbsp; &nbsp; });</pre><pre><br></pre><pre>&nbsp; &nbsp; // The main thread receives and processes messages until all senders are ready</pre><pre>&nbsp; &nbsp; drop(tx); // Close the main thread's copy of the sender so that `rx` knows that no more messages will come</pre><pre><br></pre><pre>&nbsp; &nbsp; for value in rx {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; // This iterates automatically all incoming messages</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; total_sum += value; // Append the received value</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; total_sum += 1; // Main threads own addition</pre><pre>&nbsp; &nbsp; }</pre><pre><br></pre><pre>&nbsp; &nbsp; // Print the output</pre><pre>&nbsp; &nbsp; println!("Sum at the end: {}", total_sum );</pre><pre>}<br><br></pre><strong>Example run:</strong></div><pre>Sum at the end: 102</pre><p><br></p><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15274"></a><h2>4. sleep-command and time-module</h2><h4>Sleep-command in Rust</h4>The <a href="https://doc.rust-lang.org/std/thread/fn.sleep.html">sleep</a> command delays the following commands by the amount of time given to it. It takes the <a href="https://doc.rust-lang.org/std/time/struct.Duration.html">Duration</a> type as its parameter, and not numeric values ​​directly. Duration offers different methods for giving different time measurements, such as <a href="https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs">from_secs()</a> which is given the desired number of seconds as a positive integer.<br><br>We already used the sleep command in our previous thread example, but below is a new example of how we can take advantage of threads running at different time intervals by delaying the program's operation using the sleep command.
<pre>use std::thread;<br>use std::time::Duration;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>handle = <span class="" style="color: rgb(239, 69, 64);">thread</span>::spawn(|| {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Starting another thread...");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(3)); // Sleeps 3 seconds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Another thread woke up!");<br>&nbsp;&nbsp;&nbsp; });<br>&nbsp;&nbsp;&nbsp; println!("Main thread continues...");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">thread</span>::sleep(Duration::from_secs(1)); // Sleeps 1 second<br>&nbsp;&nbsp;&nbsp; println!("The main thread is awake!");<br>&nbsp;&nbsp;&nbsp; handle.join().unwrap(); // Waiting for another thread to finish<br>&nbsp;&nbsp;&nbsp; println!("All threads ended!");<br>}</pre>
<pre>Ohjelman ajo:<br>Main thread continues...<br>Starting another thread...<br>The main thread is awake!<br>Another thread woke up!<br>All threads ended!<br><br></pre>The program first creates another thread. The main thread then prints "Main thread continues..." and then waits for a second. After this, the main thread prints the text again, after which it waits until the other thread is ready.<br><br>Another thread prints the startup println, waits three seconds, and prints another text. When everything else is done, the main thread prints that all threads have finished.<br><br>Even though the second thread is created before the main thread prints, the thread creation takes more time than the printing, which is why the main thread had time to print its first statement before the second thread.<br><br><h4>time-module</h4>
<div>
    <p data-start="27" data-end="224">Rust's std::time module provides tools for measuring time, representing time periods, and manipulating the current time. It includes several types that have different uses. We already used the Duration type in the sleep command above. Other types provided by the time module include Instant and SystemTime.</p>
    <p data-start="27" data-end="224"><br></p>
    <h5>Instant</h5>
    <div><a href="https://doc.rust-lang.org/std/time/struct.Instant.html">std::time::Instant</a> represents a precise moment in the execution of a program, and is mainly used for performance measurement. It is not tied to the system time, but only measures elapsed time relative to another Instant value.</div>
    <div><br></div>
    <div>
        <pre>use std::time::Instant;<br><br><span class="" style="color: rgb(125, 159, 211);">let </span>start = Instant::now();<br>// Execute some calculations...<br><span class="" style="color: rgb(125, 159, 211);">let </span>elapsed = start.elapsed(); // Duration of the calculations<br>println!("Code was executed in {:?} seconds", elapsed);<br><br></pre>
        <p><code><span class="" style="color: rgb(51, 51, 51);"></span></code>Instant values ​​can be compared with each other and used to calculate Duration-type values.</p>
        <pre><code><br><span class="" style="color: rgb(125, 159, 211);">let </span>later = start + Duration::from_secs(10); // 10 sekuntia myöhemmin<br><br></code></pre>
    </div>
    <h5>SystemTime</h5>
    <p><a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html">std::time::SystemTime</a> represents an absolute time based on the system clock. It can change, for example, if the user changes the time.</p>
    <p><br></p>
    <p></p>
    <h4 data-start="1909" data-end="1928">Note</h4>
    <ul data-start="1929" data-end="2186">
        <li data-start="1929" data-end="1969">Duration cannot be negative</li>
        <li data-start="1970" data-end="2034">The Instant type cannot be directly converted to a SystemTime value.</li>
        <li data-start="2035" data-end="2186">std::time does not directly provide timers, but their implementation requires other tools, such as the std::thread::sleep() we used previously</li>
    </ul>
    <p></p>
</div></div><a href="#toc">&uarr; top</a>
</body>
</html>