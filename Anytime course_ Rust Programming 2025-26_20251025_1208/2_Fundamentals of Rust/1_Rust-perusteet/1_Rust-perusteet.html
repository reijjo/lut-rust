<!doctype html>
<html>
<head>
    <title>1_Rust-perusteet</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Rust-perusteet</h1><p class="book_summary"></p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Rustin perusteet" class="font-weight-bold text-decoration-none" href="#ch15238">1. Rustin perusteet</a><ul><li><a title="1.1. Cargo-komennot" class="text-decoration-none" href="#ch15239">1.1. Cargo-komennot</a></li><li><a title="1.2. Muuttujat ja printtaus" class="text-decoration-none" href="#ch15240">1.2. Muuttujat ja printtaus</a></li><li><a title="1.3. Tyypit, Funktiot, Loopit" class="text-decoration-none" href="#ch15241">1.3. Tyypit, Funktiot, Loopit</a></li><li><a title="1.4. Sy√∂te k√§ytt√§j√§lt√§, Option ja Result -tyyppi, expect-funktio" class="text-decoration-none" href="#ch15242">1.4. Sy√∂te k√§ytt√§j√§lt√§, Option ja Result -tyyppi, expect-funktio</a></li><li><a title="1.5. use-komento" class="text-decoration-none" href="#ch15243">1.5. use-komento</a></li></ul></li></ul></div><div class="book_chapter"><a name="ch15238"></a><h2>1. Rustin perusteet</h2><p dir="ltr" style="text-align: left;">Ensimm√§isess√§ osassa k√§yd√§√§n l√§pi hy√∂dyllisi√§ dokumentaatiosivuja, Rustin hy√∂dyist√§ ja eduista sek√§ tietoa Rustista yleisesti.</p><p dir="ltr" style="text-align: left;">Seuraavissa kappaleissa k√§sitell√§√§n cargo-ty√∂kalun peruskomennot, mutable ja immutable muuttuja, printtaus, sy√∂tteen ottaminen k√§ytt√§j√§lt√§.</p><p dir="ltr" style="text-align: left;"><br></p><h4>Mik√§ on Rust?</h4>Rust on uudehko, matalan tason, suorituskykyinen ja turvallinen ohjelmointikieli. Rustin kehitys alkoi jo 2006, ja projektin kehityksen sponsorointi alkoi Mozillan toimesta 2009. Rustia k√§ytet√§√§n tehokkuutta ja turvallisuutta vaativissa sovelluksissa, sill√§ se on nopeudessa samaa tasoa C:n ja C++-kielien kanssa. C-pohjaiset kielet ovat muistinhallinnan suhteen ep√§luotettavia, sill√§ k√§ytt√§j√§lle annetaan todella paljon valtaa muistin hallinnassa, joka on yksi syy siihen miksi muistinhallinta aiheuttaa suuren osan esimerkiksi tietoturvaongelmista n√§ill√§ kielill√§.<br><br>Rustia k√§ytet√§√§n jo monissa yrityksiss√§, startupeista isoihin yrityksiin kuten Firefox (Mozillan omistama), Dropbox ja Cloudflare. Rustia hy√∂dynnet√§√§n esimerkiksi komentokehote-sovelluksissa, sulautetuissa j√§rjestelmiss√§, verkko-sovelluksissa ja WebAssemblyss√§. Rustin edut turvallisen muistinhallinnan, kehitt√§jien rakastaman syntaksin ja yhteis√∂n sek√§ kilpailukykyisen suorituskyvyn takia ovat syit√§ miksi Rust ohjelmointikieli on pit√§nyt paikkansa varsinkin tietyill√§ ohjelmoinnin osa-alueilla.<br><br><br><h4>Rustin isoimmat hy√∂dyt</h4><div>Rust kielen√§ omaa kaksi asiaa, mit√§ muista kielist√§ ei l√∂ydy, mitk√§ tekee sit√§√§ vaikeamman my√∂s opetella: Ownership, ja Lifetime. <br></div><div>Ownership liittyy muistinhallintaan, ja on yksi syy my√∂s Rustin tehokkuuteen - Rustissa ei ole esimerkiksi Java-kielen tapaan automaattista roskanker√§√§j√§√§, vaan muistia hallinnoidaan automaattisesti Ownership-tavan kautta. <br></div><div>Lifetime on k√§site joka liittyy siihen, kuinka kauan jotain muuttujaa pidet√§√§n ohjelman ajon aikana muistissa.</div><div>Koska muistinhallinta on automaattista, voi k√§ytt√§j√§ keskitty√§ enemm√§n ohjelmointiin ja mietti√§ v√§hemm√§n mahdollisia virhekohtia. Rust my√∂s ajaa ohjelmoijia ohjelmoimaan tavalla, jossa virheenk√§sittely tehd√§√§n ohjelmassa esimerkiksi Result ja Option -tyyppien avulla. Kaikki n√§m√§ edist√§v√§t sellaisten ohjelmien kirjoittamista, miss√§ muistinhallinnan virheet v√§henev√§t rutkasti, mutta tehokkuus pysyy muiden nopeiden ohjelmointikielien tasolla.</div><h4><br></h4><h4>Hy√∂dillisi√§ dokumentaatiosivuja</h4>T√§ll√§ kursilla on dokumentaatiota Suomeksi sek√§ Englanniksi kurssilla l√§pik√§yt√§vist√§ asioista, mutta dokumentaatiossa kerrotaan my√∂s, mist√§ Rustin englanninkielisen kirjan kappaleesta voi halutessaan l√∂yt√§√§ lis√§tietoa. Rustin standardikirjaston dokumentaatiosivua hy√∂dynnet√§√§n my√∂s, kun annetaan lis√§tietoa jonkin funktion k√§yt√∂st√§ - n√§it√§ sivuja on hyv√§ hy√∂dynt√§√§ oppimateriaalin ohella.<br>Rustilla on my√∂s oma Rust By Example sivu, josta l√∂ytyy k√§yt√§nn√∂n esimerkkej√§ monesta Rustin komennosta.<br><br>Rust By Example: <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">https://doc.rust-lang.org/stable/rust-by-example/index.html</a><br><br><p>Rustin oma kirja: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></p><p>Rustin dokumentaatiosivu standardikirjastolle: <a href="https://doc.rust-lang.org/stable/std/index.html">https://doc.rust-lang.org/stable/std/index.html</a></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15239"></a><h3>1.1. Cargo-komennot</h3>Asennettuasi Rustin ty√∂kaluineen, olet valmis tekem√§√§n ensimm√§isen projektisi cargo-ty√∂kalun avulla.<br><br><h4>Mik√§ on cargo?</h4>Cargo on Rustin paketinhallinta ja rakennusty√∂kalu. Cargo osaa tehd√§ monet teht√§v√§t puolestasi, kuten ohjelman k√§√§nt√§misen, ohjelmassasi m√§√§riteltyjen lis√§kirjastojen lataamisen ja n√§iden kirjastojen k√§√§nt√§misen. <br>Voit katsoa komentokehotteesta/terminaalista onko cargo ladattuna komennolla:<br><pre>cargo --version</pre><p>Jos versiota ei n√§ytet√§ vaan vastaan tulee virhekoodi, katso <strong>asennusohjeet</strong> k√§ytt√∂j√§rjestelm√§llesi uudestaan.</p><p><br></p><h4>Peruskomennot</h4>Cargon yksi perustoiminnoista on projektin luominen. Projekti voi tarkoittaa esim. t√§m√§n kurssin tapauksessa yht√§ viikkoteht√§v√§√§, sill√§ eri viikkoteht√§viss√§ voi olla eri kirjastot k√§yt√∂ss√§, ja viikkoteht√§vien teht√§v√§nannot ovat erilaisia toisistaan. Suositeltavaa on, ett√§ teet jokaiselle viikkoteht√§v√§lle oman projektin.<br><br>Uuden projektin voi luoda komennolla:<br><pre>cargo new projektin_nimi --bin</pre><p><em>cargo new </em><span>-komento luo uuden projektin antamallasi nimell√§. --bin parametri tekee suoritettavan ohjelman projektista, kirjaston sijaan. Cargo luo kansion nimelt√§ projektin_nimi - antamasi nimi - jossa on useita tiedostoja.</span></p><p><span>T√§rkeimm√§t tiedostot toistaiseksi ovat Cargo.toml, joka on kansion p√§√§tasolla, sek√§ src-kansiossa oleva main.rs tiedosto. Rust tiedostot loppuvat rs-p√§√§tteeseen.</span></p><p><span><br></span></p><h4><span>Cargo.toml tiedoston sis√§lt√∂:<br></span></h4><pre><span>[package]<br>name = "projektin_nimi"<br>version = "0.1.0"<br>authors = ["opiskelija"]<br>[dependencies]<br></span></pre><h4><br></h4><div>Cargo.toml tiedosto sis√§lt√§√§ tietoa projektista. Se perustuu TOML (Tom's Obvious, Minimal Language) formaattiin.</div><div><br></div><div><br></div><h4>Ulkoisten kirjastojen k√§ytt√∂</h4><div>Jos ohjelmasi k√§ytt√§√§ ulkoisia kirjastoja - joita k√§ytet√§√§n useita eri t√§ll√§ kurssilla - tulee sinun lis√§t√§ tarvittaessa viikkoteht√§v√§n projektin Cargo.toml tiedostoon <em>[dependencies] </em><span>-kohdan alapuolelle tarvittavat kirjastot. Alla esimerkki <a href="https://docs.rs/rand/latest/rand/">rand</a>-kirjaston k√§ytt√§misest√§ projektissa:<br></span></div><div><span><br></span></div><div><span><pre><span>[dependencies]</span><br>rand = "0.8.5"<br><br></pre></span><p><span style="font-weight: normal;">Kun k√§ytt√§j√§ lis√§√§ kirjaston Cargo.toml tiedostoon ja projektin k√§ytett√§v√§ksi, seuraavalla build-komennolla tai run-komennolla cargo osaa k√§√§nt√§√§ kirjaston suoritettavaan muotoon, jotta sen tuomia komentoja voi k√§ytt√§√§. Tiedostossa m√§√§ritell√§√§n mik√§ versio kirjastosta l√∂ytyy. Uusin saatavilla oleva versio l√∂ytyy kirjaston dokumentaatiosta.<br></span></p><p><span style="font-weight: normal;"><br></span></p><span></span><span><h4><span>Projektin rakentaminen ja ajaminen:</span></h4>Ollessasi projektikansion sis√§ll√§, voidaan projekti rakentaa k√§ytt√§m√§ll√§ komentoa:</span></div><pre>cargo build</pre>Yll√§oleva komento k√§√§nt√§√§ ohjelmasi suoritettavaan muotoon.<br>Suoritettavat tiedostot luodaan <em>target</em><span>-kansioon. Samalla cargo luo tiedoston <em>C</em></span><em><span>argo.lock</span></em><span><span>, joka pit√§√§ kirjaa tarkoista versionumeroista mit√§ projektissa k√§ytet√§√§n. Joskus k√§ytt√§m√§si kirjasto voi sis√§ll√§√§n k√§ytt√§√§ muita kirjastoja, jotka n√§kyv√§t <em>Cargo.lock</em> tiedostossa. T√§h√§n tiedostoon sinun ei tarvitse itse koskea, sill√§ cargo hoitaa t√§m√§n automaattisesti.<br><br>Cargo voi k√§√§nt√§√§ sek√§ ajaa projektisi ollessasi projektikansion sis√§ll√§, komennolla:<br></span></span><pre><span><span>cargo run</span></span><br><span><span></span></span></pre><p>Jos tiedostot ovat muuttuneet viime ohjelman ajokerran j√§lkeen, cargo k√§√§nt√§√§ tiedostot uudestaan ja sitten ajaa ohjelmasi.</p><p>K√§ytt√§m√§ll√§<em> new</em><span>, <em>run</em><span> ja <em>build</em><span> komentoa p√§√§set jo pitk√§lle cargon k√§yt√∂n kanssa.</span></span></span><br></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15240"></a><h3>1.2. Muuttujat ja printtaus</h3><p dir="ltr" style="text-align: left;"></p>T√§ss√§ kappaleessa perehdyt√§√§n Rustin muuttujiin ja printtaukseen/tulostukseen.<p></p>

<h4 dir="ltr" style="text-align: left;">Muuttujat</h4>
<div>Rustissa, kuten k√§yt√§nn√∂ss√§ kaikissa ohjelmointikieliss√§, on muuttujia. Rustissa muuttujien k√§ytt√∂ eroaa monista kielist√§ Rustin <em>ownership</em><span>-ominaisuuden takia. Monissa muissa kieliss√§ muuttujat ovat l√§ht√∂kohtaisesti muutettavia - mutable - eli niiden arvoja voi muuttaa. Rustissa asia on toisinp√§in.</span></div>
<div><span><br></span></div>
<div><span>Jotta muuttujan arvoa voi Rustissa muuttaa, pit√§√§ sille antaa lis√§tietona <em>mut</em> avainsana, joka tarkoittaa "<a href="https://www.suomisanakirja.fi/englanti/mutable">mutable</a>". <br></span></div>
<div><span><br></span></div>
<div><span>Esimerkki Rustin normaalista muuttujasta, sek√§ mutable-muuttujasta:<br></span>
    <pre><span>   <span class="" style="background-color: rgb(255, 255, 255); color: rgb(255, 255, 255);"> <span class="" style="color: rgb(125, 159, 211);">let</span></span> x = 5;       // immutable muuttuja
    // x = 10;       // T√§m√§ antaisi virheen, koska x on immutable

    <span class="" style="color: rgb(125, 159, 211);">let </span><span class="" style="color: rgb(125, 159, 211);">mut </span>y = 10;  // mutable muuttuja
    y = 20;           // T√§m√§ on sallittua, koska y on mutable</span><br><span></span></pre>

</div>
<br>

<p><span>Jos k√§ytt√§j√§ yritt√§√§ muokata muuttujaa, jota ei ole merkattu muokattavaksi, antaa Rust siit√§ virhekoodin. Yll√§olevassa esimerkiss√§ n√§emme mik√§ on sallittua ja mik√§ ei. // -merkint√§ tarkoittaa kommenttirivi√§, eli sit√§, ett√§ kyseist√§ rivi√§ ei ohjelmassa ajeta. Esimerkiksi <em>x</em><em> = 10</em> on kommentoitu siksi, koska yrit√§mme muuttaa muuttujaa mik√§ ei ole <em>mutable</em>, joten Rust ei antaisi k√§√§nt√§√§ ohjelmaa vaan antaisi virhekoodin.</span></p>
<p><span><br></span></p>
<h4>Tulostus/Printtaus</h4>Monien muiden ohjelmointikielien tavalla Rust tarjoaa tavan printata eli tulostaa teksti√§ komentokehotteeseen. Voit tulostaa valitsemasi tekstin lainausmerkkien sis√§ll√§, antaa yhden tai useamman muuttujan hakasulkeiden sis√§ll√§ printattavassa lauseessa, k√§ytt√§√§ hakasulkeita paikkamerkkein√§ ja listata k√§ytett√§v√§t muuttujat j√§rjestyksess√§ pilkun j√§lkeen. Alla esimerkkej√§ tulostusfunktion erilaisista k√§ytt√∂tavoista.<br>Huom! Muuttujilla suoritettavat laskut eiv√§t muuta alkuper√§ist√§ arvoa, joten mutable arvon k√§ytt√∂√§ ei esimerkkitulostuksissa tarvita:<br><br>
<div><pre>&nbsp; &nbsp; <span class="" style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);">println</span>!("Hei, opiskelen Rustia!");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let</span> nimi = "Matti";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(51, 51, 51);">println!</span>("Nimi on: {nimi}");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>luku = 5;</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>kerrottu = luku * 2;</pre><pre>&nbsp; &nbsp; println!("Luku: {luku}, kerrottu: {kerrottu}");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="background-color: rgb(255, 255, 255); color: rgb(125, 159, 211);">let </span>a = 3;</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>b = 4;</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>c = a * a + b * b;</pre><pre>&nbsp; &nbsp; println!("Hypotenuusa: {c}");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="background-color: rgb(255, 255, 255); color: rgb(125, 159, 211);">let </span>nimi = "Matti";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>ik√§ = 30;</pre><pre>&nbsp; &nbsp; println!("Nimi: {}, Ik√§: {}", nimi, ik√§);</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>nimi = "Rust";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>version = "1.64";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tulos = 42;</pre><pre>&nbsp; &nbsp; println!("Tervetuloa {} versioon {}! Tulos: {}", nimi, version, tulos);</pre><div><br></div><div><br></div><div><h4>Esimerkkikoodin ajo</h4><div><br></div>Jos haluat ajaa yll√§olevan esimerkkikoodin, muista, ett√§ Rustissa pit√§√§ aina olla main-funktio. Luotuasi projektin <em>cargo new</em><span> komennolla, laita yll√§oleva esimerkkiohjelma main-funktion sis√§√§n.</span></div><pre><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span></pre><pre><span>    // esimerkkiohjelma t√§n√§ne</span></pre><div><p><span></span></p><pre><span>    println</span>!("Hei, opiskelen Rustia!");<br>    jne...<br>}</pre><p></p><pre><span><pre><br></pre></span></pre><h5><strong>Esimerkkiohjelman ajon tulostus:</strong></h5></div><pre>Hei, opiskelen Rustia!<br>Nimi on: Matti<br>Luku: 5, kerrottu: 10<br>Hypotenuusa: 25<br>Nimi: Matti, Ik√§: 30<br>Tervetuloa Rust versioon 1.64! Tulos: 42</pre><div><br></div><div><br></div></div></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15241"></a><h3>1.3. Tyypit, Funktiot, Loopit</h3><p dir="ltr"></p>T√§ss√§ kappaleessa perehdyt√§√§n Rustin vastineisiin yleisist√§ ohjelmointik√§sitteist√§.<br><br><h4>Rustin tyypit</h4>Rustissa on useita tyyppej√§. Koska Rust on <a href="https://fi.wikipedia.org/wiki/Tyyppij%C3%A4rjestelm%C3%A4#Staattinen_vs._dynaaminen_tyypitys">staattisesti tyypitetty kieli</a>, sen t√§ytyy tiet√§√§ kaikki tyypit ohjelman k√§√§nn√∂svaiheessa ennen ohjelman suoritusta. Tyypit on erikseen jaettu skalaareihin - yksitt√§isiin arvoihin - ja yhdistetyyppeihin (compound type).<br><br><div><br></div><div><strong>Muuttujan m√§√§rittely:</strong></div><pre><span class="" style="color: rgb(125, 159, 211);">let </span>muuttujan_nimi: muuttujan_tyyppi = muuttujan_arvo;<br></pre><p><a href="https://doc.rust-lang.org/std/keyword.let.html">let</a>-avainsana mahdollista muuttujan luonnin. Muuttujan nimi tulee let-avainsanan j√§lkeen. Kaksoispisteen j√§lkee tulee muuttujan tyyppi, jonka j√§lkeen annetaan <strong>= </strong><span>merkin j√§lkeen muuttujan arvo. Muuttujan tyyppi voi olla jokin yksitt√§inen tyyppi, lista yksitt√§isist√§ tyypeist√§, tai esimerkiksi structin instanssi - structeista lis√§√§ my√∂hemmill√§ viikoilla.</span></p><br><h5>Skalaarityypit</h5><p>Skalaarityyppej√§ on nelj√§:</p><ul><li><p>Int</p></li><li><p>Float</p></li><li><p>Boolean</p></li><li><p>Character</p></li></ul><p><strong>Int-tyyppi√§</strong> on eri kokoisia:</p><ul><li><p>8bit</p></li><li><p>16bit</p></li><li><p>32bit</p></li><li><p>64bit</p></li></ul><div><br></div><br><p>Int-tyypin eri koot m√§√§ritell√§√§n esimerkiksi:</p><pre><span class="" style="color: rgb(125, 159, 211);">let</span> numero: i8 = 5;</pre><pre><span class="" style="color: rgb(125, 159, 211);">let </span>numero_2: i32 = 10000;<br><br></pre><p><strong>Int-tyypit</strong><span><span><span> </span></span></span>voivat olla my√∂s vain positiivisia, tai sek√§ positiivisia ett√§ negatiivisia. Jos vain positiiviset arvot ovat sallittuja, <a href="https://doc.rust-lang.org/std/u32/constant.MAX.html">maksimiarvo</a> k√§yt√§nn√∂ss√§ tuplaantuu <a href="https://doc.rust-lang.org/std/i32/constant.MAX.html">samankokoiseen etumerkittyyn arvoon</a> verrattuna.<br></p><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
    // Signed integers - etumerkityt arvot, positiiviset tai negatiiviset arvot k√§y<br>    // esim. i32 - arvot v√§lilt√§ -2147483648 ja 2147483647 sallittuja<br>
    <span class="" style="color: rgb(125, 159, 211);">let </span>arvo_1: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= -42;         // Esimerkki negatiivisesta arvosta
    <span class="" style="color: rgb(125, 159, 211);">let </span>arvo_2: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= 42; // Esimerkki positiivisesta arvosta

    // Unsigned integers - ei-etumerkityt arvot, vain positiiviset arvot k√§y<br>    // esim. u32 - arvot v√§lilt√§ 0 ja 4294967295 sallittuja
    <span class="" style="color: rgb(125, 159, 211);">let </span>arvo_3: <span class="" style="color: rgb(125, 159, 211);">u32 </span>= 42;        // Esimerkki positiivisesta arvosta
    // let invalid: <span class="" style="color: rgb(51, 51, 51);">u32 </span>= -42;     // T√§m√§ ei toimi, unsigned ei voi olla negatiivinen
}<br></pre><pre><br></pre><p><strong>Float tyyppi√§ </strong>on kahta kokoa:</p><ul><li>32bit</li><li>64bit</li></ul>Nekin m√§√§ritell√§√§n vastaavasti:<br><pre><span class="" style="color: rgb(125, 159, 211);">let </span>liukuluku: f32 = 2.345;<br><br><span class="" style="color: rgb(125, 159, 211);">let </span>liukuluku: f64 = 2.345678;</pre><br><strong><span>Boolean-tyyppi</span> </strong>on joko true tai false:<br><br><pre><span class="" style="color: rgb(125, 159, 211);">let </span>boolean_arvo = true;<br><span class="" style="color: rgb(125, 159, 211);">let </span>boolean_arvo_2: <span class="" style="color: rgb(125, 159, 211);">bool </span>= false; // explisiittisell√§ tyyppi-merkinn√§ll√§<br><br></pre><p><span><strong><span><span><span>Character-tyypp</span>i</span></span></strong><span><strong><span> </span></strong>voi olla </span><span>yksitt√§inen merkki, mutta merkki voi tarkoittaa t√§ss√§ tapauksessa muutakin kuin l√§nsimaista kirjainta - Japania, Koreaa, Kiinaa, emojia, nollaleveydellist√§ v√§lily√∂nti√§ - kaikki ovat valideja merkkej√§ Rustissa. Rust k√§ytt√§√§ Univode Scalar Value -arvoja. <br></span></span></p><p><span><span>Merkit m√§√§ritell√§√§n single-quotejen,<strong> ' '</strong>, avulla, toisinkuin merkkijonot, jotka k√§ytt√§v√§t tupla-lainausmerkki√§, <strong>" "</strong>.<strong> <br></strong></span></span></p><pre><span><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>c = 'z';<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>z = '∆µ';<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>emoji = 'üòª';<br>}</span><strong><br><br></strong></span></span></pre><h5><span><span><strong>Yhdistetyypit</strong></span></span><br><span><span><strong></strong></span></span></h5><p>Yhdistetyyppej√§ k√§yd√§√§n l√§pi enemm√§n viikolla 2. Niihin kuuluu:</p><ul><li>Array-tyyppi</li><li>Tuple-tyyppi</li></ul><div><br></div><div><br></div><div><br></div><h4>String ja &amp;str - merkkijono Rustissa</h4><p>Rustissa on sek√§ String sliceja, sek√§ String-tyyppi erikseen.</p><p>String tyyppi on k√§yt√§nn√∂llinen, kun kysyt√§√§n esimerkiksi k√§ytt√§j√§lt√§ dataa. String slice tarvitsee tiedon, kuinka pitk√§ annettu arvo tulee olemaan. T√§m√§ ei ole mahdollista kun annetaan k√§ytt√§j√§lle mahdollisuus antaa dataa. Datan kokoa ei voida etuk√§teen tiet√§√§. String slicea ei voi my√∂sk√§√§n muokata.<br></p><p>String-tyyppi mahdollistaa dynaamisen datan hallinnan ohjelmaa ajaessa. Data tallennetaan heap-osioon stackin sijaan. Heap-osio on hitaampi tapa k√§sitell√§ muistia, mutta se mahdollistaa muuttuvan koon muuttujan, kuten String-tyypin olemassaolon.</p><p>String-tyypin tyyppi on String.</p><p>String slicen tyyppi on &amp;str.<br></p><p><br></p><pre>// String-tyypin luominen
<span class="" style="color: rgb(125, 159, 211);">let </span>oma_stringi = String::from("T√§m√§ on String-tyyppi"); // Dynaaminen merkkijono, luo String-tyypin string-slicest√§<br>
// String slicen luominen &amp;str
<span class="" style="color: rgb(125, 159, 211);">let </span>string_slice: &amp;str = &amp;oma_stringi[0..4];             // Viittaa osaan Stringist√§ (0‚Äì3 merkki√§, sis√§lt√∂ on: "T√§m√§")

// String-slice vakiona
<span class="" style="color: rgb(125, 159, 211);">let </span>vakio_slice: &amp;str = "T√§m√§ on string slice vakiona";  // T√§m√§ on jo slice

// String-tyypin muokkaaminen
<span class="" style="color: rgb(125, 159, 211);">let mut</span> muokattava_string = String::from("Muokattava");
muokattava_string.push_str(" String");                    // Lis√§t√§√§n sis√§lt√∂√§ Stringiin<br></pre><p><br></p><p></p>

<h4 dir="ltr">Funktiot</h4>
<div>Rustissa, kuten k√§yt√§nn√∂ss√§ kaikissa ohjelmointikieliss√§, on funktioita, looppeja, sek√§ tapoja kysy√§ sy√∂tett√§ k√§ytt√§j√§lt√§. T√§ss√§ k√§ymme perusk√§ytt√∂tavat tutuista k√§sitteist√§ l√§vitse esimerkkitiedoston kautta.</div><div><br></div><pre>// Tyhj√§ esimerkkifunktio</pre><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>esimerkki(parametri_1: <span class="" style="color: rgb(125, 159, 211);">parameterin tyyppi</span>, parametri_2: <span class="" style="color: rgb(125, 159, 211);">parametrin_2_tyyppi</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">palautusarvon_tyyppi </span>{<br>&nbsp;&nbsp;&nbsp; //koodia<br>    palautusarvo<br>}<br></pre><div><br></div><p>Yll√§ olevasta esimerkkifunktiosta n√§emme Rust-kielen funktion yleisen rakenteen ja toimintaperiaatteen.</p><p>Rustissa funktio m√§√§ritell√§√§n avainsanalla <strong><span class="" style="color: rgb(125, 159, 211);">fn</span></strong>, jota seuraa funktion nimi. Parametrit m√§√§ritell√§√§n sulkeiden sis√§ll√§ nimipari-muodossa, jossa parametriin liittyy aina sen tyyppi, erotettuna kaksoispisteell√§ (<strong>:</strong>). Parametrit erotellaan toisistaan pilkulla (<strong>,</strong>). Funktion palautusarvon tyyppi m√§√§ritell√§√§n nuolella (<strong>-&gt;</strong>) funktion nimen ja parametrilistan j√§lkeen.</p><p>Rust on vahvasti tyypitetty kieli, joten sek√§ parametrien ett√§ palautusarvon tyypit on aina m√§√§ritelt√§v√§ eksplisiittisesti. T√§m√§ auttaa est√§m√§√§n monia virheit√§ jo k√§√§nn√∂saikana.</p><p>Jos funktiolla on palautusarvo, se ilmoitetaan nuolella (<strong>-&gt;</strong>) ja arvon tyypill√§. Kaikilla funktioilla ei ole palautusarvoa, jos funktio esimerkiksi tulostaa annetut arvot tietyll√§ formatointitavalla.<br></p>Erona moneen muuhun ohjelmointikieleen, funktion viimeinen lauseke (ilman puolipistett√§) toimii automaattisesti palautusarvona. Jos funktiossa on puolipiste viimeisess√§ lausekkeessa, se ei palauta mit√§√§n, ja palautusarvona on ( ) (unit-tuple).<br><br>Alla n√§emme lis√§√§ esimerkkej√§ erilaisista funktioista.<br>Ensimm√§inen funktio tulostaa "Testifunktio", ei palauta mit√§√§n, eik√§ ota yht√§√§n parametria.<br><p></p><div><br></div><pre><span>// Funktio, joka tulostaa "Testifunktio"
<span class="" style="color: rgb(125, 159, 211);">fn </span>testifunktio() {
    println!("Testifunktio");
}<br><br></span></pre><p><span>Toinen funktio tulostaa annetun i32 arvon, k√§ytt√§en hakasulkeita paikkamerkkin√§. Palautusarvoa ei ole.<br></span></p><pre><span>
// Funktio, joka ottaa int-muuttujan ja tulostaa sen formatoituna print-lauseeseen
<span class="" style="color: rgb(125, 159, 211);">fn </span>tulosta_kuvaus(arvo: <span class="" style="color: rgb(125, 159, 211);">i32</span>) {
    println!("Annettu arvo on: {}", arvo);
}<br><br></span></pre><p><span>Kolmas funktio ottaa kaksi i32 arvoa parametrina, summaa ne yhteen tallettaen arvon uuteen muuttujaan, ja printtaa formatoituna annetut luvut sek√§ niiden summan. Palautusarvoa ei ole.<br></span></p><pre><span>
// Funktio, joka ottaa kaksi int-muuttujaa, summaa ne ja tulostaa summan
<span class="" style="color: rgb(125, 159, 211);">fn </span>tulosta_summa(a: <span class="" style="color: rgb(125, 159, 211);">i32</span>, b: <span class="" style="color: rgb(125, 159, 211);">i32</span>) {
    let summa = a + b;
    println!("Lukujen {} ja {} summa on: {}", a, b, summa);
}<br><br></span></pre><p><span>Nelj√§s funktio ottaa kaksi liukulukua, f64, su</span><span>mmaa ne yhteen ja palauttaa summan. Palautusarvo on, ja se on tyypilt√§√§n f64. Funktion viimeisess√§ lauseessa ei ole puolipistett√§, joten se loppuu siihen, ja automaattisesti palauttaa summatun arvon.</span><span>

</span></p><pre><span>// Funktio, joka ottaa kaksi liukulukua, summaa ne ja palauttaa summan
<span class="" style="color: rgb(125, 159, 211);">fn </span>summaa_liukuluvut(a: <span class="" style="color: rgb(125, 159, 211);">f64</span>, b: <span class="" style="color: rgb(125, 159, 211);">f64</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">f64 </span>{
    a + b
}<br></span></pre>
<p>P√§√§funktio l√∂ytyy jokaisesta Rust-projektista. Se luodaan my√∂s <em>cargo new</em> komentoa k√§ytt√§ess√§. Olemme m√§√§ritelleet nelj√§ muuta funktiota, joita kutsumme eri arvoilla. Kun funktiot ovat m√§√§ritelty, niit√§ voi kutsua. P√§√§funktiossa kutsumme jokaista funktiota j√§rjestyksess√§, antaen tarvittavat arvot oikeine tyyppeineen funktioille. Viimeisen funktion kohdalla, sen palauttaessa f64 arvon, tallennamme sen muuttujaan p√§√§funktiossa ja tulostamme sen k√§ytt√§j√§lle.<br></p><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
    testifunktio();
    tulosta_kuvaus(42);
    tulosta_summa(10, 15);
    <span class="" style="color: rgb(125, 159, 211);">let </span>summa = summaa_liukuluvut(3.14, 2.71);
    println!("Liukuluvut summattuna: {}", summa);
}<br></pre><p><br></p><h4>Loopit</h4><div>Rustissa on perinteisen <a href="https://doc.rust-lang.org/std/keyword.if.html">if</a>-lauseen lis√§ksi <a href="https://doc.rust-lang.org/std/keyword.loop.html">loop</a>-rakenne, joka on yksinkertaisin looppi, joka rikkoutuu kun k√§ytt√§j√§ kutsuu break-komentoa. Match-rakenne on switch-case rakenteen kaltainen, joka vertaa annettua arvoa,&nbsp; ja palauttaa arvoa vastaavan kohdan. Jos annettu arvo ei ole match-listassa, voidaan m√§√§ritell√§ "<strong>_</strong>", joka suoritetaan jos annettua arvoa ei l√∂ytynyt match-rakenteesta. <a href="https://doc.rust-lang.org/std/keyword.while.html">while</a>-rakenne on tuttu muista kielist√§.<br></div><div><br></div><p><span style="font-weight: normal;"><strong>Match-rakenteesta</strong> on esimerkki alla. Funktio ottaa i32 arvon, ja jos arvo on 1, 2 tai 3, se printtaa kyseisen arvon kohdalla olevan lauseen. Jos arvo on joku muu kuin 1, 2 tai 3, suorittaa funktio "_" kohdalla olevan koodin. Match-funktio on k√§tev√§, kun halutaan tehd√§ eri asioita perustuen annettuun arvoon. Match-rakennetta voi esimerkiksi k√§ytt√§√§ menussa, jossa k√§ytt√§j√§ sy√∂tt√§√§ mit√§ h√§n haluaa tehd√§. Match-rakenne suorittaa k√§ytt√§j√§n sy√∂tteell√§ annetun toiminnan.</span><br></p><div><br></div><pre><span style="font-weight: normal;"><div><div>// Match-lauseen k√§ytt√∂</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>match_funktio(luku: &amp;<span class="" style="color: rgb(125, 159, 211);">mut i32</span>) {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>*luku {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1 =&gt; println!("Luku on yksi"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2 =&gt; println!("Luku on kaksi"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3 =&gt; println!("Luku on kolme"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; _ =&gt; println!("Luku on jotain muuta"), // _ on "catch-all" -haara</div><div>&nbsp; &nbsp; }</div><div>}</div><br></div><br><br></span></pre><p><strong>If-rakenteesta</strong> on esimerkki alla. Funktio ottaa luku-nimiseen muuttujaan kokonaislukuarvon, ja suorittaa koodin if-lauseen ehtojen perusteella.<br><span style="font-weight: normal;"></span></p><pre><span style="font-weight: normal;"><br><div><div>// If-lauseen k√§ytt√∂</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>if_funktio(luku: &amp;mut i32) {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>*luku &gt; 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on suurempi kuin viisi");</div><div>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else if</span> *luku &lt; 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on pienempi kuin viisi");</div><div>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else </span>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on tasan viisi");</div><div>&nbsp; &nbsp; }</div><div>}</div></div><br><br></span></pre><p><span style="font-weight: normal;"><strong>Loop-rakenne</strong> vastaa while-rakenteen tyyli√§ joka on tuttu monesta muusta ohjelmointikielest√§. Looppia jatketaan, kunnes k√§ytt√§j√§ kutsuu <em>break</em><span>-komentoa. T√§m√§ rikkoo silmukan. Loopin sis√§ll√§ voi k√§ytt√§√§ my√∂s muita rakenteita, kuten if-lausetta, jotta lopettamisehto voidaan varmistaa. Muista, ett√§ jokaisessa loopissa kannattaa olla jokin arvo, joka muuttuu kuten alla olevan esimerkin laskuriarvo, johon lis√§t√§√§n joka kierroksella 1. Kun arvo saavuttaa luvun 5, looppi lopetataan. Jos mit√§√§n t√§m√§nkaltaista ehtoa ei ole, looppi jatkuisi loputtomiiin.</span></span><br><span style="font-weight: normal;"></span></p><pre><span style="font-weight: normal;"><div><div>// Loop-rakenteen k√§ytt√∂</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>loop_funktio() {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> laskuri = 0;</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>laskuri == 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!("Loop p√§√§ttyy, koska laskuri saavutti arvon {}", laskuri);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">break</span>; // Pys√§ytt√§√§ silmukan</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Loop-laskuri on: {}", laskuri);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; laskuri += 1; // Kasvatetaan laskuria</div><div>&nbsp; &nbsp; }</div><div>}</div><br></div><br><br></span></pre><p>While-rakenne on samanlainen Rustissa kuin muissa kieliss√§. While-lausekkeen sis√§lle tulee ehto, jonka t√§yttyess√§ loopin suoritus lopetetaan.<br></p><pre><span style="font-weight: normal;"><br><div><div>// While-rakenteen k√§ytt√∂</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>while_funktio(laskuri: &amp;mut i32) {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">while </span>*laskuri &lt; 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("While-laskuri on: {}", laskuri);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *laskuri += 1;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; println!("While p√§√§ttyy, koska laskuri saavutti arvon {}", laskuri);</div><div>}</div></div><br><br></span></pre><p>Huomioi, ett√§ if-lausetta, looppia, ja match-rakennetta voidaan k√§ytt√§√§ my√∂s funktioiden ulkopuolella vaikkapa main-funktion sis√§ll√§. Ne eiv√§t vaadi erillist√§ funktioita, vaan niit√§ satuttiin k√§ytt√§m√§√§n funktoiden sis√§ll√§ esimerkeiss√§.<br></p><p>Pohdintateht√§v√§: mieti, mit√§ yll√§olevat funktiot tulostavat, kun niit√§ kutsutaan alla olevassa main-funktiossa annetulla muuttujalla <em>numero</em><span>, jonka arvo on 3.</span><br></p><pre><span style="font-weight: normal;"><br></span></pre><pre><span><span class="" style="color: rgb(125, 159, 211);"></span><div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</div><div>&nbsp; &nbsp; // Esimerkki match-lauseesta</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> numero = 3;</div><div>&nbsp; &nbsp; match_funktio(&amp;mut numero);</div><br><div>&nbsp; &nbsp; // Esimerkki if-lauseesta</div><div>&nbsp; &nbsp; numero = 3; // Resetoi numero</div><div>&nbsp; &nbsp; if_funktio(&amp;mut numero);</div><br><div>&nbsp; &nbsp; // Esimerkki loop-rakenteesta</div><div>&nbsp; &nbsp; loop_funktio();</div><br><div>&nbsp; &nbsp; // Esimerkki while-rakenteesta</div><div>&nbsp; &nbsp; numero = 0; // Resetoi numero</div><div>&nbsp; &nbsp; while_funktio(&amp;mut numero);</div><div>}</div></div><br></span></pre><br><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15242"></a><h3>1.4. Sy√∂te k√§ytt√§j√§lt√§, Option ja Result -tyyppi, expect-funktio</h3><p dir="ltr" style="text-align: left;">T√§ss√§ kappaleessa opetellaan kysym√§√§n k√§ytt√§j√§lt√§ sy√∂tett√§, ja parsimaan se tarvittaessa oikeaan muotoon.<br></p><p></p>
<p dir="ltr"><br></p>
<h4 dir="ltr">Sy√∂tteen kysyminen</h4><div>Rust-tarjoaa k√§ytt√§j√§n sy√∂tteen kysymiseen standardikirjaston ty√∂kaluja<br></div><pre><span class="" style="color: rgb(125, 159, 211);">use </span>std::io;<br></pre><p>T√§m√§ rivi tuo Rustin standardikirjaston (<a href="https://doc.rust-lang.org/std/index.html">std</a>) sis√§ll√§ olevan<code></code><a href="https://doc.rust-lang.org/std/io/index.html#standard-input-and-output"> io-moduulin</a> k√§ytt√∂√∂n.<br><span><span></span><a href="https://doc.rust-lang.org/std/io/index.html#standard-input-and-output">io</a> </span><span>(</span>input/output) tarjoaa toiminnallisuuksia k√§ytt√§j√§n sy√∂tteen lukemiseen (<strong>stdin</strong><span>)</span> ja tulostamiseen (<strong>stdout</strong><span> ja <strong>stderr</strong><span>).</span></span></p><p><span><span>Moduuleita k√§ymme tarkemmin l√§vitse my√∂hemmiss√§ osioissa.<br></span></span></p><p><span><span>K√§yd√§√§n alla oleva esimerkkikoodi l√§pi osio osiolta, jotta saamme k√§sityksen kuinka peruskomentoja sy√∂tteen kysymiseen ja k√§sittelyyn voidaan io-moduulista k√§ytt√§√§.</span></span></p><pre><span class="" style="color: rgb(125, 159, 211);"><span class="" style="color: rgb(51, 51, 51);">use std::io;</span><br>fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Kysyt√§√§n sanaa<br>&nbsp;&nbsp;&nbsp; println!("Anna sana:");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut </span>sana = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>sana).expect("Virhe sy√∂tteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let</span> sana = sana.trim(); // Poistetaan rivinvaihdot sy√∂tteest√§<br>&nbsp;&nbsp;&nbsp; println!("Annoit sanan: {}", sana);<br><br></pre><p>Ensimm√§isess√§ osioissa printtaamme k√§ytt√§j√§lle informatiivisen viestin, mit√§ haluamme k√§ytt√§j√§lt√§. Alustamme tyhj√§n merkkijonomuuttujan, joka on mutable, eli voimme muokata sit√§ tarvittaessa. <br></p><p>Kysymme k√§ytt√§j√§lt√§ rivin, k√§ytt√§en io-moduulin stdin-alimoduulin <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line </a>funktiota.&nbsp; read_line ottaa sis√§√§ns√§ mutable muuttujan, ja t√§ss√§ tapauksessa referencen eli viittauksen, joka on verrattavissa esim. pointteriin C++:sta. Referencen tunnistaa "<strong>&amp;</strong><span>" -merkist√§ ennen muuttujaa, ja liittyy Rustin Ownership-konseptiin, jota k√§sittelemme viikolla 2. Rivin onnistuneen suorituksen j√§lkeen k√§ytt√§j√§n antama sy√∂te, joka p√§√§ttyy siis uuteen riviin tai esimerkiksi komentokehotteessa enter-ly√∂ntiin, on tallennettu muuttujaan <em>kirjain</em><span>.</span><em><br></em></span></p><p>Readlinen per√§ss√§ on my√∂s yksinkertainen virheenhallintakutsu, <em>expect</em><span>, jota k√§sittelemme my√∂hemmin. <br></span></p><p><span>Koska sy√∂te tallennetaan sellaisenaan, pit√§√§ sy√∂tett√§ siisti√§ k√§ytt√§m√§ll√§ standardikirjaston <a href="https://doc.rust-lang.org/std/primitive.str.html#method.trim">trim</a>-komentoa. Trim-komento poistaa rivinvaihdot sy√∂tteest√§.</span></p><p><span>Alla olevassa esimerkkikoodissa tehd√§√§n sama kuin √§sk√∂n, mutta lis√§ksi k√§ytet√§√§n if-lauserakennetta hy√∂dyksi ja kutsumme <a href="https://doc.rust-lang.org/std/primitive.str.html#method.len">len</a>-funktiota standardikirjastosta selvitt√§√§ksemme sy√∂ttik√∂ k√§ytt√§j√§ ennem√§n kuin yhden merkin.<br></span></p><pre><br>&nbsp;&nbsp;&nbsp; // Kysyt√§√§n kirjainta<br>&nbsp;&nbsp;&nbsp; println!("Anna kirjain:");<br>&nbsp;&nbsp;&nbsp;<span class="" style="color: rgb(125, 159, 211);"> let mut </span>kirjain = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>kirjain).expect("Virhe sy√∂tteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>kirjain = kirjain.trim(); // Poistetaan rivinvaihdot sy√∂tteest√§<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>kirjain.len() == 1 {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Annoit kirjaimen: {}", kirjain);<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Sy√∂tteen pit√§isi olla yksi kirjain!");<br>&nbsp;&nbsp;&nbsp; }<br><br></pre><p><span>Seuraavassa osiossa kysymme k√§ytt√§j√§lt√§ kokonaisluvun. Luomme uuden muuttujan, joka on my√∂s String-tyyppi√§, kutsumme taas read_line funktiota, annamme parametriksi luomamme muuttujan <em>kokonaisluku</em><span> viittauksen kanssa, ja lopussa on virheenhallintalause, <em>expect</em><span>.<br></span></span></span></p><p><span><span><span>Koska luku tallennettaan String-muuttujaan, pit√§√§ luku siisti√§. T√§ss√§ esimerkiss√§ luomme t√§t√§ varten uuden, non-mutable kokonaislukumuuttujan, josta ensin otamme pois rivinvaihdot trim-komennolla ja sitten yrit√§mme muuttaa String-tyypin tekstin tyypiksi i32 standardikirjaston <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">parse</a>-komennolla. Lopussa <em>expect</em><span>-virheenhallintakomento, sek√§ tulostus.</span></span></span></span></p><p><span><span><span><span>Alempana on samanlainen esimerkki mutta liukuluvulla. Muista, ett√§ luvuksi tallentaminen vaatii aina tyypin muuton parse-komentoa k√§ytt√§en. Merkille ja merkkijonolle riitt√§√§ pelkk√§ trim. Muista k√§ytt√§√§ viittauksia sek√§ mutable-muuttujia.<br></span><em></em></span> </span><em></em></span></p><pre><br>&nbsp;&nbsp;&nbsp; // Kysyt√§√§n kokonaisluku<br>&nbsp;&nbsp;&nbsp; println!("Anna kokonaisluku:");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> kokonaisluku = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut</span> kokonaisluku).expect("Virhe sy√∂tteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>kokonaisluku: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= kokonaisluku.trim().parse().expect("Sy√∂te ei ole kelvollinen kokonaisluku");<br>&nbsp;&nbsp;&nbsp; println!("Annoit kokonaisluvun: {}", kokonaisluku);<br><br>&nbsp;&nbsp;&nbsp; // Kysyt√§√§n liukuluku<br>&nbsp;&nbsp;&nbsp; println!("Anna liukuluku (esim. 3.14):");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> liukuluku = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut</span> liukuluku).expect("Virhe sy√∂tteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>liukuluku: <span class="" style="color: rgb(125, 159, 211);">f64 </span>= liukuluku.trim().parse().expect("Sy√∂te ei ole kelvollinen liukuluku");<br>&nbsp;&nbsp;&nbsp; println!("Annoit liukuluvun: {}", liukuluku);<br>}<br></pre><pre><br></pre><strong>Match-lause</strong> <strong>s<span>y√∂tteen kanssa<br></span></strong><span><span>Kysyess√§si esimerkiksi lukusy√∂tett√§ k√§ytt√§j√§lt√§, kannattaa k√§ytt√§√§ match-lausetta simppelin rakenteen hy√∂dynt√§miseksi.<br></span></span>Parse palauttaa <em>Result</em><span> -tyypin, joka on hy√∂dyllinen ja yleinen tapa k√§sitell√§ dataa Rustissa. Jos jotain dataa on, palautetaan t√§m√§ data. Jos l√∂ytyy virhe, voidaan t√§ss√§ esimerkkitapauksessa tulostaa haluamamme virhekoodi: <em>Parsiminen ep√§onnistui</em><span>. Jos tutkit rakennetta hieman, huomaat, ett√§ rakenne vastaa match-lauseen rakennetta. Jos parsiminen onnistui, voi parsed_int-muuttujaa k√§ytt√§√§ normaalisti t√§m√§n j√§lkeen.<br>Lis√§√§ <a href="https://doc.rust-lang.org/std/result/index.html">Result</a>-tyypist√§ ja <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">parsesta</a>.<br></span></span><br><div><pre><span class="" style="color: rgb(125, 159, 211);"><span class="" style="color: rgb(51, 51, 51);">use std::io;</span><br>fn </span>main() {</pre><pre>&nbsp; &nbsp; println!("Anna luku: ");</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> kayttajan_syote = String::new();</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut</span> kayttajan_syote).expect("Error occurred.");<br><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>parsed_int: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= match kayttajan_syote.trim().parse() {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(152, 202, 62); background-color: rgb(255, 255, 255);">Ok</span>(luku) =&gt; luku, </pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(152, 202, 62);">Err</span>(_) =&gt; {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!("Parsiminen ep√§onnistui.");</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">return</span>;</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; }</pre><pre>&nbsp; &nbsp; }; &nbsp;<br><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>parsed_int &lt; 0 {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp;println!("Luku on alle 0.");</pre><pre>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else if </span>parsed_int &gt; 100 {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on yli 100.");</pre><pre>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else </span>{</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on 0 ja 100 v√§lilt√§.");</pre><pre>&nbsp; &nbsp; }</pre><pre>}<br><br><br></pre><h5>Except-komento</h5><div>Rustissa expect on metodi, jota k√§ytet√§√§n <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a>- tai <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a>-tyypin kanssa. Se antaa mahdollisuuden k√§sitell√§ virheit√§ yksinkertaisesti. Jos operaatio ep√§onnistuu,<code> </code><em>expect </em>tulostaa siihen liittyv√§n virheilmoituksen ja lopettaa ohjelman (eli panikoi).</div><div>Alla n√§emme esimerkin tiedostonk√§sittelyst√§ standardikirjaston moduuleita hy√∂dynt√§m√§ll√§. Yritt√§ess√§mme avata tiedostoa, k√§ytt√§m√§ <em>expect</em><span>i√§ kertomaan jos tiedoston avaaminen ep√§onnistuu.</span></div><div><span>Tiedoston k√§sittely√§ k√§ymme l√§pi tarkemmin my√∂hemm√§ss√§ luvussa.<br></span></div><div><br></div><div><div><pre><span class="" style="color: rgb(125, 159, 211);">use </span>std::fs::File;</pre><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>file = <span class="" style="color: rgb(239, 69, 64);">File</span>::open("tiedosto.txt").expect("Tiedoston avaaminen ep√§onnistui!");</pre><pre>&nbsp; &nbsp; println!("Tiedosto avattiin onnistuneesti: {:?}", file);</pre><pre>}</pre><br></div></div><h5>Result ja Option -tyyppi</h5><h5><span style="font-weight: normal;">Result j</span><span style="font-weight: normal;">a Option ovat Rustin erityisi√§ enum-tyyppej√§, joita k√§ytet√§√§n turvalliseen virheiden ja vaihtoehtoisten arvojen k√§sittelyyn. Ne ovat olennainen osa Rustin tapaa v√§ltt√§√§ "paniikkia" (ohjelman kaatumista, Rustissa panic) ja k√§ytt√§√§ tyyppij√§rjestelm√§√§ varmistamaan virheiden asianmukainen hallinta.</span></h5><div><br></div><div><strong>Result</strong></div><div>Result-tyyppi√§ k√§ytet√§√§n ilmaisemaan joko onnistumista tai virhetilaa operaatioissa. Se on m√§√§ritelty n√§in:</div><div><br></div><pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Result&lt;T, E&gt; {<br>&nbsp;&nbsp;&nbsp; Ok(T),&nbsp; // Onnistumisen tapauksessa sis√§lt√§√§ arvon T<br>&nbsp;&nbsp;&nbsp; Err(E), // Virheen tapauksessa sis√§lt√§√§ virheen E<br>}<br></pre><ul><li>T on tyyppi onnistuneelle paluuarvolle</li><li>E on tyyppi virheelle</li></ul><div><br></div><h4>Esimerkki:</h4></div><pre>use std::fs::File;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tulos = <span class="" style="color: rgb(239, 69, 64);">File</span>::open("olemassa_olematon_tiedosto.txt");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>tulos {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok(tiedosto) =&gt; println!("Tiedosto avattiin onnistuneesti!"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err(virhe) =&gt; println!("Tiedoston avaaminen ep√§onnistui: {}", virhe),<br>&nbsp;&nbsp;&nbsp; }<br>}</pre><p>T√§ss√§ <em>File::open</em> palauttaa <em>Result&lt;File, std::io::Error&gt;</em>. Jos tiedosto l√∂ytyy, se palauttaa <em>Ok(File)</em>. Jos tiedostoa ei l√∂ydy, se palauttaa <em>Err(std::io::Error)</em>.</p><p><br></p><p><strong>Option</strong><br></p><p>Option-tyyppi√§ k√§ytet√§√§n, kun arvo voi olla olemassa tai puuttua. Se on m√§√§ritelty n√§in:</p><pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Option&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp; Some(T), // Kun arvo on olemassa<br>&nbsp;&nbsp;&nbsp; None,&nbsp;&nbsp;&nbsp; // Kun arvo puuttuu&nbsp;</pre><pre>}</pre><p><br></p><ul><li>T on tyyppi, jota Option voi sis√§lt√§√§</li><li>None tarkoittaa, ett√§ arvoa ei ole</li></ul><div><br></div><div><strong>Esimerkki:</strong></div><div><pre><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>hae_arvo(indeksi: <span class="" style="color: rgb(125, 159, 211);">usize</span>) -&gt; Option&lt;<span class="" style="color: rgb(125, 159, 211);">i32</span>&gt; {</span></span><br><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>luvut = vec![10, 20, 30];</span></span><br><span><span>&nbsp;&nbsp;&nbsp; luvut.get(indeksi).cloned()</span></span><br><span><span>}</span></span><br><span><span></span></span><br><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span></span><br><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>hae_arvo(1) {</span></span><br><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Some(arvo) =&gt; println!("Arvo l√∂ytyi: {}", arvo),</span></span><br><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None =&gt; println!("Arvoa ei l√∂ytynyt!"),</span></span><br><span><span>&nbsp;&nbsp;&nbsp; }</span></span><br><span><span>}</span></span><strong><span></span></strong><br><strong><span></span></strong></pre><strong><span><br></span></strong></div><div><span><span>T√§ss√§ get-metodi palauttaa <em>Option&lt;T&gt;</em>:</span></span></div><ul><li><span><span><span>Jos indeksi on kelvollinen, funktio palauttaa <em>Some(arvo)</em></span></span></span></li><li><span><span><span>Jos indeksi ei ole kelvollinen, se palauttaa <em>None</em>.<br></span></span></span></li></ul><div>Koska annettu indeksi on esimerkiss√§ 1, arvo l√∂ytyi, palautusarvo on<em> Some(arvo)</em> ja arvo on 20.</div><div><br></div><div><br></div><div><strong>Unwrap-komento - yksinkertainen tapa saada data ulos Optionista ja Resultista</strong></div><div><em>unwrap()</em> <span>on nopea keino purkaa arvoja ilman ylim√§√§r√§ist√§ virhek√§sittely√§, mutta se on riskialtis produktiokoodissa. Panikointi virhetilanteissa voi johtaa ohjelman odottamattomaan kaatumiseen.</span><strong><br></strong></div><div><strong><br></strong></div><div><pre><span><span><span class="" style="color: rgb(125, 159, 211);">let </span>value: Option&lt;<span class="" style="color: rgb(125, 159, 211);">i32</span>&gt; = 5;</span></span><br><span><span></span><span>println!("Value: {}", value.unwrap()); // Tulostaa: Value: 5</span></span><br><strong></strong></pre><span>unwrap-komentoa voi k√§ytt√§√§ match-lauseen sijasta, mutta suositeltavampaa on k√§ytt√§√§ esim. match-lausetta</span></div><div><span>unwrap-komentoa voi k√§ytt√§√§ kaikkien tyyppien kanssa, jotka palauttavat Result-tai Option-tyypin (esim. File::open)<br></span><strong></strong></div><div><br></div><div><strong>Mik√§ on Result ja Option -tyypin erot?<br></strong></div><div><span><span><em>Result</em>-tyyppi√§ k√§ytet√§√§n, kun operaatiolla on mahdollisuus ep√§onnistua ja tarvitset virheen selitt√§miseen liittyv√§√§ tietoa (Err).</span></span></div><div><span><span><em>Option</em>-tyyppi√§ k√§ytet√§√§n, kun arvo saattaa puuttua, mutta virheen syy ei ole tarpeen. <br></span></span></div><div><span><span><br></span></span><strong><span></span></strong></div><div><strong><span><br></span></strong></div><div><strong>M<span><span>ik√§ hy√∂ty on n√§iden tyyppien k√§ytt√§misest√§?</span></span></strong></div><div><span><span><span><span><em>Result</em>- ja <em>Option</em>-tyypin k√§ytt√∂ auttaa v√§ltt√§m√§√§n null-viitteit√§ - Optionin <em>None </em>korvaa monesta kielest√§ tutun null arvon.</span></span></span></span></div><div><span><span><span><span>N√§m√§ tyypit my√∂s varmistavat, ett√§ k√§sittelet virheet eksplisiittisesti.<br></span></span></span></span><strong><span><span><span></span></span></span></strong></div><div><strong><span><br></span></strong></div><div><strong><span><br></span></strong></div><div><strong>M<span><span>ik√§ &lt;T&gt;?</span></span></strong></div><div><span><span><span><span><em>&lt;T&gt;</em> on Rustissa generinen tyyppiparametri, jota k√§ytet√§√§n tekem√§√§n funktioista, rakenteista, metodeista tai enumeista tyypist√§ riippumattomia. Geneerisyys mahdollistaa sen, ett√§ voit kirjoittaa yleisk√§ytt√∂ist√§ koodia, joka toimii eri tyyppien kanssa ilman, ett√§ sinun tarvitsee toistaa samaa koodia jokaiselle tyypille erikseen.<br></span></span></span></span></div><div><strong><span><span><span><span><br></span></span></span></span></strong></div><div><strong><span><span><span><span><br></span></span></span></span></strong></div><div><strong><span><span><span><span>Miten geneerinen tyyppi toimii?</span></span></span></span></strong><span><span><span><span><p><em>&lt;T&gt;</em> toimii kuin <span>paikkamerkkin√§ tyypille </span>, joka p√§√§tet√§√§n my√∂hemmin ‚Äì joko koodin kutsun yhteydess√§ tai k√§√§nt√§j√§n p√§√§ttelyn avulla. Rustissa geneerinen tyyppi on aina tarkasti m√§√§ritelty k√§√§nn√∂svaiheessa, joten ohjelma ei sis√§ll√§ ylim√§√§r√§ist√§ suoritusajan ylikuormaa geneerisyydest√§. Rustissa k√§√§nt√§j√§ luo geneerisest√§ koodista erilliset toteutukset kaikille tarvittaville tyypeille (prosessia kutsutaan <strong>monomorfisoinniksi</strong>). T√§m√§ tarkoittaa, ett√§ generics tarjoaa sek√§ suorituskyvyn ett√§ joustavuuden ilman kompromisseja tyyppiturvassa.<strong> </strong>T√§m√§ aihe menee tarkemmin jo lis√§tietona, mutta sis√§llytettiin tiedoksi <em>Option</em>-tyypin ja <em>Result</em>-tyypin takia - n√§m√§ tyypit k√§ytt√§v√§t geneerist√§ arvoa T, jotta k√§ytt√§j√§ voi k√§ytt√§√§ n√§iss√§ mit√§ tyyppi√§ tahansa.<strong><br></strong></p><p><span><span>Geneerisist√§ tyypeist√§ lis√§√§ Rustin kirjan kappaleessa 10</span></span><strong><span>.</span></strong></p><p><span><span>Option ja Result tyypist√§ lis√§√§ kappaleessa 6.</span></span></p><p><span><span><br></span></span></p></span></span></span></span></div><div><br></div><code></code><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15243"></a><h3>1.5. use-komento</h3><p dir="ltr" style="text-align: left;"></p><h4>use-komento</h4><div><p>Rustissa avainsana <em>use </em>on osa 
moduulij√§rjestelm√§√§, ja sit√§ k√§ytet√§√§n tuomaan nimi√§ (kuten funktioita, 
rakenteita, enumeja tai traitteja) k√§ytt√∂√∂n toisista moduuleista tai 
kirjastoista. T√§m√§ tekee koodista helpommin luettavaa ja v√§ltt√§√§ tarpeen
 kirjoittaa pitki√§ nimiavaruuksia toistuvasti.</p><p><br></p><h4>use-avainsanan esimerkki<br></h4><pre>use std::fs::File;<br>use std::io::{self, Read};<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() -&gt; <span class="" style="color: rgb(239, 69, 64);">io</span>::Result&lt;()&gt; {<br>    // Avataan olemassa oleva tiedosto<br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> tiedosto = <span class="" style="color: rgb(125, 159, 211);">match </span><span class="" style="color: rgb(239, 69, 64);">File</span>::open("esimerkki.txt") {<br>        Ok(file) =&gt; file,<br>        Err(e) =&gt; {<br>            eprintln!("Virhe avattaessa tiedostoa: {}", e);<br>            return Err(e);<br>        }<br>    };<br><br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> sis√§lt√∂ = String::new();<br><br>    // Luetaan tiedoston sis√§lt√∂ merkkijonoksi<br>    <span class="" style="color: rgb(125, 159, 211);">match </span>tiedosto.read_to_string(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>sis√§lt√∂) {<br>        Ok(_) =&gt; println!("Tiedoston sis√§lt√∂:\n{}", sis√§lt√∂),<br>        Err(e) =&gt; {<br>            eprintln!("Virhe luettaessa tiedostoa: {}", e);<br>            return Err(e);<br>        }<br>    }<br><br>    Ok(())<br>}<br><br></pre><p>Esimerkkitiedostomme:</p><pre><img src="data/kuva%20%281%29.png" alt="" role="presentation" class="img-fluid"><br><br></pre><p>Esimerkki-ajo:</p><pre>Tiedoston sis√§lt√∂:<br>Esimerkki<br>teksti√§<br>t√§nne!</pre></div>Rustin <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> -moduuli tarjoaa kaikki tarvittavat ty√∂kalut sek√§ tiedostojen lukemiseen ett√§ kirjoittamiseen.&nbsp; Kun k√§ytt√§m√§ use-avainsanaa, voimme tuoda fs-moduulin tarjoamia moduuleita k√§ytt√∂√∂mme. Esimerkiksi:<br><pre>use std::io::{self, Read};</pre>tuo std-kirjaston osia k√§ytt√∂√∂mme.<br><br><h3>Osat:</h3><ol><li><p><strong><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code></strong><span class="" style="color: rgb(51, 51, 51);">:</span></p><ul><li><strong><code><span class="" style="color: rgb(51, 51, 51);">std</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>on Rustin standardikirjasto.</span></li><li><strong><code><span class="" style="color: rgb(51, 51, 51);">io</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>on standardikirjaston moduuli, joka tarjoaa sy√∂te- ja tulostetoimintoja, kuten kirjoittamista, lukemista ja virheenk√§sittely√§.</span></li></ul></li><li><p><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>self</strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p><ul><li><strong><code><span class="" style="color: rgb(51, 51, 51);">self</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>viittaa siihen, ett√§ koko </span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code><span class="" style="color: rgb(51, 51, 51);">-moduuli tuodaan k√§ytt√∂√∂n sellaisenaan.</span></li><li><span class="" style="color: rgb(51, 51, 51);">T√§m√§n ansiosta voit k√§ytt√§√§ esimerkiksi </span><code><span class="" style="color: rgb(51, 51, 51);">io::Result</span></code><span class="" style="color: rgb(51, 51, 51);">, </span><code><span class="" style="color: rgb(51, 51, 51);">io::Error</span></code><span class="" style="color: rgb(51, 51, 51);">, tai muita </span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code><span class="" style="color: rgb(51, 51, 51);">-moduulin ominaisuuksia suoraan ilman pitk√§√§ nime√§ </span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code><span class="" style="color: rgb(51, 51, 51);">.</span></li></ul></li><li><p><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>Write</strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p><ul><li><span class="" style="color: rgb(51, 51, 51);">T√§m√§ tuo </span><code><span class="" style="color: rgb(51, 51, 51);">Write</span></code><span class="" style="color: rgb(51, 51, 51);">-traitin k√§ytt√∂√∂n, joka tarjoaa ominaisuudet tiedon kirjoittamiseen. Esimerkiksi:</span><ul><li><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>write</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Kirjoittaa raakadataa.</span></span></li><li><code><span class="" style="color: rgb(51, 51, 51);"><strong>write_all</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Kirjoittaa kaiken annetun datan.</span></li><li><code><span class="" style="color: rgb(51, 51, 51);"><strong>writeln!</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Makro, joka kirjoittaa tekstirivin ja lis√§√§ rivinvaihdon.</span></li></ul></li><li><code><span class="" style="color: rgb(51, 51, 51);"><strong>Write</strong></span></code><span class="" style="color: rgb(51, 51, 51);">-traitia tarvitaan tiedostoihin kirjoittamisessa tai tulosteiden ohjaamisessa.</span></li></ul></li><li>
        <p><span><code><span><strong><span class="" style="color: rgb(51, 51, 51);">Read</span></strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p>
        <ul>
            <li><span><span class="" style="color: rgb(51, 51, 51);">T√§m√§ tuo </span><span><code><span class="" style="color: rgb(51, 51, 51);">Read </span></code></span><span class="" style="color: rgb(51, 51, 51);">traitin k√§ytt√∂√∂mme, joka tarjoaa ominaisuudet tiedon lukemiseen tiedostosta. Esimerkiksi:</span></span><ul>
                    <li><span><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Lukee raakadataa tavuina.</span></span></li>
                    <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read_to_string</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Lukee annetun datan String-muotoon.</span></li>
                    <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read_exact</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Lukee annetun m√§√§r√§n tavuja annetusta datasta.</span></li>
                </ul>
            </li>
            <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">Read</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">-traitia tarvitaan tiedostojen lukuun.</span></li></ul></li></ol>K√§ytt√§m√§ll√§ <em>use</em>-lausetta voimme pit√§√§ koodin siistin√§ ja helposti luettavana.<br>Traiteist√§ lis√§√§ kirjan kappaleessa 10.<br><p></p></div><a href="#toc">&uarr; top</a>
</body>
</html>