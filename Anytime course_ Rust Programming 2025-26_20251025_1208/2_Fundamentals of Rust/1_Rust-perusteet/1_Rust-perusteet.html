<!doctype html>
<html>
<head>
    <title>1_Rust-perusteet</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Rust-perusteet</h1><p class="book_summary"></p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Rustin perusteet" class="font-weight-bold text-decoration-none" href="#ch15238">1. Rustin perusteet</a><ul><li><a title="1.1. Cargo-komennot" class="text-decoration-none" href="#ch15239">1.1. Cargo-komennot</a></li><li><a title="1.2. Muuttujat ja printtaus" class="text-decoration-none" href="#ch15240">1.2. Muuttujat ja printtaus</a></li><li><a title="1.3. Tyypit, Funktiot, Loopit" class="text-decoration-none" href="#ch15241">1.3. Tyypit, Funktiot, Loopit</a></li><li><a title="1.4. Syöte käyttäjältä, Option ja Result -tyyppi, expect-funktio" class="text-decoration-none" href="#ch15242">1.4. Syöte käyttäjältä, Option ja Result -tyyppi, expect-funktio</a></li><li><a title="1.5. use-komento" class="text-decoration-none" href="#ch15243">1.5. use-komento</a></li></ul></li></ul></div><div class="book_chapter"><a name="ch15238"></a><h2>1. Rustin perusteet</h2><p dir="ltr" style="text-align: left;">Ensimmäisessä osassa käydään läpi hyödyllisiä dokumentaatiosivuja, Rustin hyödyistä ja eduista sekä tietoa Rustista yleisesti.</p><p dir="ltr" style="text-align: left;">Seuraavissa kappaleissa käsitellään cargo-työkalun peruskomennot, mutable ja immutable muuttuja, printtaus, syötteen ottaminen käyttäjältä.</p><p dir="ltr" style="text-align: left;"><br></p><h4>Mikä on Rust?</h4>Rust on uudehko, matalan tason, suorituskykyinen ja turvallinen ohjelmointikieli. Rustin kehitys alkoi jo 2006, ja projektin kehityksen sponsorointi alkoi Mozillan toimesta 2009. Rustia käytetään tehokkuutta ja turvallisuutta vaativissa sovelluksissa, sillä se on nopeudessa samaa tasoa C:n ja C++-kielien kanssa. C-pohjaiset kielet ovat muistinhallinnan suhteen epäluotettavia, sillä käyttäjälle annetaan todella paljon valtaa muistin hallinnassa, joka on yksi syy siihen miksi muistinhallinta aiheuttaa suuren osan esimerkiksi tietoturvaongelmista näillä kielillä.<br><br>Rustia käytetään jo monissa yrityksissä, startupeista isoihin yrityksiin kuten Firefox (Mozillan omistama), Dropbox ja Cloudflare. Rustia hyödynnetään esimerkiksi komentokehote-sovelluksissa, sulautetuissa järjestelmissä, verkko-sovelluksissa ja WebAssemblyssä. Rustin edut turvallisen muistinhallinnan, kehittäjien rakastaman syntaksin ja yhteisön sekä kilpailukykyisen suorituskyvyn takia ovat syitä miksi Rust ohjelmointikieli on pitänyt paikkansa varsinkin tietyillä ohjelmoinnin osa-alueilla.<br><br><br><h4>Rustin isoimmat hyödyt</h4><div>Rust kielenä omaa kaksi asiaa, mitä muista kielistä ei löydy, mitkä tekee sitää vaikeamman myös opetella: Ownership, ja Lifetime. <br></div><div>Ownership liittyy muistinhallintaan, ja on yksi syy myös Rustin tehokkuuteen - Rustissa ei ole esimerkiksi Java-kielen tapaan automaattista roskankerääjää, vaan muistia hallinnoidaan automaattisesti Ownership-tavan kautta. <br></div><div>Lifetime on käsite joka liittyy siihen, kuinka kauan jotain muuttujaa pidetään ohjelman ajon aikana muistissa.</div><div>Koska muistinhallinta on automaattista, voi käyttäjä keskittyä enemmän ohjelmointiin ja miettiä vähemmän mahdollisia virhekohtia. Rust myös ajaa ohjelmoijia ohjelmoimaan tavalla, jossa virheenkäsittely tehdään ohjelmassa esimerkiksi Result ja Option -tyyppien avulla. Kaikki nämä edistävät sellaisten ohjelmien kirjoittamista, missä muistinhallinnan virheet vähenevät rutkasti, mutta tehokkuus pysyy muiden nopeiden ohjelmointikielien tasolla.</div><h4><br></h4><h4>Hyödillisiä dokumentaatiosivuja</h4>Tällä kursilla on dokumentaatiota Suomeksi sekä Englanniksi kurssilla läpikäytävistä asioista, mutta dokumentaatiossa kerrotaan myös, mistä Rustin englanninkielisen kirjan kappaleesta voi halutessaan löytää lisätietoa. Rustin standardikirjaston dokumentaatiosivua hyödynnetään myös, kun annetaan lisätietoa jonkin funktion käytöstä - näitä sivuja on hyvä hyödyntää oppimateriaalin ohella.<br>Rustilla on myös oma Rust By Example sivu, josta löytyy käytännön esimerkkejä monesta Rustin komennosta.<br><br>Rust By Example: <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">https://doc.rust-lang.org/stable/rust-by-example/index.html</a><br><br><p>Rustin oma kirja: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></p><p>Rustin dokumentaatiosivu standardikirjastolle: <a href="https://doc.rust-lang.org/stable/std/index.html">https://doc.rust-lang.org/stable/std/index.html</a></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15239"></a><h3>1.1. Cargo-komennot</h3>Asennettuasi Rustin työkaluineen, olet valmis tekemään ensimmäisen projektisi cargo-työkalun avulla.<br><br><h4>Mikä on cargo?</h4>Cargo on Rustin paketinhallinta ja rakennustyökalu. Cargo osaa tehdä monet tehtävät puolestasi, kuten ohjelman kääntämisen, ohjelmassasi määriteltyjen lisäkirjastojen lataamisen ja näiden kirjastojen kääntämisen. <br>Voit katsoa komentokehotteesta/terminaalista onko cargo ladattuna komennolla:<br><pre>cargo --version</pre><p>Jos versiota ei näytetä vaan vastaan tulee virhekoodi, katso <strong>asennusohjeet</strong> käyttöjärjestelmällesi uudestaan.</p><p><br></p><h4>Peruskomennot</h4>Cargon yksi perustoiminnoista on projektin luominen. Projekti voi tarkoittaa esim. tämän kurssin tapauksessa yhtä viikkotehtävää, sillä eri viikkotehtävissä voi olla eri kirjastot käytössä, ja viikkotehtävien tehtävänannot ovat erilaisia toisistaan. Suositeltavaa on, että teet jokaiselle viikkotehtävälle oman projektin.<br><br>Uuden projektin voi luoda komennolla:<br><pre>cargo new projektin_nimi --bin</pre><p><em>cargo new </em><span>-komento luo uuden projektin antamallasi nimellä. --bin parametri tekee suoritettavan ohjelman projektista, kirjaston sijaan. Cargo luo kansion nimeltä projektin_nimi - antamasi nimi - jossa on useita tiedostoja.</span></p><p><span>Tärkeimmät tiedostot toistaiseksi ovat Cargo.toml, joka on kansion päätasolla, sekä src-kansiossa oleva main.rs tiedosto. Rust tiedostot loppuvat rs-päätteeseen.</span></p><p><span><br></span></p><h4><span>Cargo.toml tiedoston sisältö:<br></span></h4><pre><span>[package]<br>name = "projektin_nimi"<br>version = "0.1.0"<br>authors = ["opiskelija"]<br>[dependencies]<br></span></pre><h4><br></h4><div>Cargo.toml tiedosto sisältää tietoa projektista. Se perustuu TOML (Tom's Obvious, Minimal Language) formaattiin.</div><div><br></div><div><br></div><h4>Ulkoisten kirjastojen käyttö</h4><div>Jos ohjelmasi käyttää ulkoisia kirjastoja - joita käytetään useita eri tällä kurssilla - tulee sinun lisätä tarvittaessa viikkotehtävän projektin Cargo.toml tiedostoon <em>[dependencies] </em><span>-kohdan alapuolelle tarvittavat kirjastot. Alla esimerkki <a href="https://docs.rs/rand/latest/rand/">rand</a>-kirjaston käyttämisestä projektissa:<br></span></div><div><span><br></span></div><div><span><pre><span>[dependencies]</span><br>rand = "0.8.5"<br><br></pre></span><p><span style="font-weight: normal;">Kun käyttäjä lisää kirjaston Cargo.toml tiedostoon ja projektin käytettäväksi, seuraavalla build-komennolla tai run-komennolla cargo osaa kääntää kirjaston suoritettavaan muotoon, jotta sen tuomia komentoja voi käyttää. Tiedostossa määritellään mikä versio kirjastosta löytyy. Uusin saatavilla oleva versio löytyy kirjaston dokumentaatiosta.<br></span></p><p><span style="font-weight: normal;"><br></span></p><span></span><span><h4><span>Projektin rakentaminen ja ajaminen:</span></h4>Ollessasi projektikansion sisällä, voidaan projekti rakentaa käyttämällä komentoa:</span></div><pre>cargo build</pre>Ylläoleva komento kääntää ohjelmasi suoritettavaan muotoon.<br>Suoritettavat tiedostot luodaan <em>target</em><span>-kansioon. Samalla cargo luo tiedoston <em>C</em></span><em><span>argo.lock</span></em><span><span>, joka pitää kirjaa tarkoista versionumeroista mitä projektissa käytetään. Joskus käyttämäsi kirjasto voi sisällään käyttää muita kirjastoja, jotka näkyvät <em>Cargo.lock</em> tiedostossa. Tähän tiedostoon sinun ei tarvitse itse koskea, sillä cargo hoitaa tämän automaattisesti.<br><br>Cargo voi kääntää sekä ajaa projektisi ollessasi projektikansion sisällä, komennolla:<br></span></span><pre><span><span>cargo run</span></span><br><span><span></span></span></pre><p>Jos tiedostot ovat muuttuneet viime ohjelman ajokerran jälkeen, cargo kääntää tiedostot uudestaan ja sitten ajaa ohjelmasi.</p><p>Käyttämällä<em> new</em><span>, <em>run</em><span> ja <em>build</em><span> komentoa pääset jo pitkälle cargon käytön kanssa.</span></span></span><br></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15240"></a><h3>1.2. Muuttujat ja printtaus</h3><p dir="ltr" style="text-align: left;"></p>Tässä kappaleessa perehdytään Rustin muuttujiin ja printtaukseen/tulostukseen.<p></p>

<h4 dir="ltr" style="text-align: left;">Muuttujat</h4>
<div>Rustissa, kuten käytännössä kaikissa ohjelmointikielissä, on muuttujia. Rustissa muuttujien käyttö eroaa monista kielistä Rustin <em>ownership</em><span>-ominaisuuden takia. Monissa muissa kielissä muuttujat ovat lähtökohtaisesti muutettavia - mutable - eli niiden arvoja voi muuttaa. Rustissa asia on toisinpäin.</span></div>
<div><span><br></span></div>
<div><span>Jotta muuttujan arvoa voi Rustissa muuttaa, pitää sille antaa lisätietona <em>mut</em> avainsana, joka tarkoittaa "<a href="https://www.suomisanakirja.fi/englanti/mutable">mutable</a>". <br></span></div>
<div><span><br></span></div>
<div><span>Esimerkki Rustin normaalista muuttujasta, sekä mutable-muuttujasta:<br></span>
    <pre><span>   <span class="" style="background-color: rgb(255, 255, 255); color: rgb(255, 255, 255);"> <span class="" style="color: rgb(125, 159, 211);">let</span></span> x = 5;       // immutable muuttuja
    // x = 10;       // Tämä antaisi virheen, koska x on immutable

    <span class="" style="color: rgb(125, 159, 211);">let </span><span class="" style="color: rgb(125, 159, 211);">mut </span>y = 10;  // mutable muuttuja
    y = 20;           // Tämä on sallittua, koska y on mutable</span><br><span></span></pre>

</div>
<br>

<p><span>Jos käyttäjä yrittää muokata muuttujaa, jota ei ole merkattu muokattavaksi, antaa Rust siitä virhekoodin. Ylläolevassa esimerkissä näemme mikä on sallittua ja mikä ei. // -merkintä tarkoittaa kommenttiriviä, eli sitä, että kyseistä riviä ei ohjelmassa ajeta. Esimerkiksi <em>x</em><em> = 10</em> on kommentoitu siksi, koska yritämme muuttaa muuttujaa mikä ei ole <em>mutable</em>, joten Rust ei antaisi kääntää ohjelmaa vaan antaisi virhekoodin.</span></p>
<p><span><br></span></p>
<h4>Tulostus/Printtaus</h4>Monien muiden ohjelmointikielien tavalla Rust tarjoaa tavan printata eli tulostaa tekstiä komentokehotteeseen. Voit tulostaa valitsemasi tekstin lainausmerkkien sisällä, antaa yhden tai useamman muuttujan hakasulkeiden sisällä printattavassa lauseessa, käyttää hakasulkeita paikkamerkkeinä ja listata käytettävät muuttujat järjestyksessä pilkun jälkeen. Alla esimerkkejä tulostusfunktion erilaisista käyttötavoista.<br>Huom! Muuttujilla suoritettavat laskut eivät muuta alkuperäistä arvoa, joten mutable arvon käyttöä ei esimerkkitulostuksissa tarvita:<br><br>
<div><pre>&nbsp; &nbsp; <span class="" style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);">println</span>!("Hei, opiskelen Rustia!");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let</span> nimi = "Matti";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(51, 51, 51);">println!</span>("Nimi on: {nimi}");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>luku = 5;</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>kerrottu = luku * 2;</pre><pre>&nbsp; &nbsp; println!("Luku: {luku}, kerrottu: {kerrottu}");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="background-color: rgb(255, 255, 255); color: rgb(125, 159, 211);">let </span>a = 3;</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>b = 4;</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>c = a * a + b * b;</pre><pre>&nbsp; &nbsp; println!("Hypotenuusa: {c}");</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="background-color: rgb(255, 255, 255); color: rgb(125, 159, 211);">let </span>nimi = "Matti";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>ikä = 30;</pre><pre>&nbsp; &nbsp; println!("Nimi: {}, Ikä: {}", nimi, ikä);</pre><pre><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>nimi = "Rust";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>version = "1.64";</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tulos = 42;</pre><pre>&nbsp; &nbsp; println!("Tervetuloa {} versioon {}! Tulos: {}", nimi, version, tulos);</pre><div><br></div><div><br></div><div><h4>Esimerkkikoodin ajo</h4><div><br></div>Jos haluat ajaa ylläolevan esimerkkikoodin, muista, että Rustissa pitää aina olla main-funktio. Luotuasi projektin <em>cargo new</em><span> komennolla, laita ylläoleva esimerkkiohjelma main-funktion sisään.</span></div><pre><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span></pre><pre><span>    // esimerkkiohjelma tänäne</span></pre><div><p><span></span></p><pre><span>    println</span>!("Hei, opiskelen Rustia!");<br>    jne...<br>}</pre><p></p><pre><span><pre><br></pre></span></pre><h5><strong>Esimerkkiohjelman ajon tulostus:</strong></h5></div><pre>Hei, opiskelen Rustia!<br>Nimi on: Matti<br>Luku: 5, kerrottu: 10<br>Hypotenuusa: 25<br>Nimi: Matti, Ikä: 30<br>Tervetuloa Rust versioon 1.64! Tulos: 42</pre><div><br></div><div><br></div></div></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15241"></a><h3>1.3. Tyypit, Funktiot, Loopit</h3><p dir="ltr"></p>Tässä kappaleessa perehdytään Rustin vastineisiin yleisistä ohjelmointikäsitteistä.<br><br><h4>Rustin tyypit</h4>Rustissa on useita tyyppejä. Koska Rust on <a href="https://fi.wikipedia.org/wiki/Tyyppij%C3%A4rjestelm%C3%A4#Staattinen_vs._dynaaminen_tyypitys">staattisesti tyypitetty kieli</a>, sen täytyy tietää kaikki tyypit ohjelman käännösvaiheessa ennen ohjelman suoritusta. Tyypit on erikseen jaettu skalaareihin - yksittäisiin arvoihin - ja yhdistetyyppeihin (compound type).<br><br><div><br></div><div><strong>Muuttujan määrittely:</strong></div><pre><span class="" style="color: rgb(125, 159, 211);">let </span>muuttujan_nimi: muuttujan_tyyppi = muuttujan_arvo;<br></pre><p><a href="https://doc.rust-lang.org/std/keyword.let.html">let</a>-avainsana mahdollista muuttujan luonnin. Muuttujan nimi tulee let-avainsanan jälkeen. Kaksoispisteen jälkee tulee muuttujan tyyppi, jonka jälkeen annetaan <strong>= </strong><span>merkin jälkeen muuttujan arvo. Muuttujan tyyppi voi olla jokin yksittäinen tyyppi, lista yksittäisistä tyypeistä, tai esimerkiksi structin instanssi - structeista lisää myöhemmillä viikoilla.</span></p><br><h5>Skalaarityypit</h5><p>Skalaarityyppejä on neljä:</p><ul><li><p>Int</p></li><li><p>Float</p></li><li><p>Boolean</p></li><li><p>Character</p></li></ul><p><strong>Int-tyyppiä</strong> on eri kokoisia:</p><ul><li><p>8bit</p></li><li><p>16bit</p></li><li><p>32bit</p></li><li><p>64bit</p></li></ul><div><br></div><br><p>Int-tyypin eri koot määritellään esimerkiksi:</p><pre><span class="" style="color: rgb(125, 159, 211);">let</span> numero: i8 = 5;</pre><pre><span class="" style="color: rgb(125, 159, 211);">let </span>numero_2: i32 = 10000;<br><br></pre><p><strong>Int-tyypit</strong><span><span><span> </span></span></span>voivat olla myös vain positiivisia, tai sekä positiivisia että negatiivisia. Jos vain positiiviset arvot ovat sallittuja, <a href="https://doc.rust-lang.org/std/u32/constant.MAX.html">maksimiarvo</a> käytännössä tuplaantuu <a href="https://doc.rust-lang.org/std/i32/constant.MAX.html">samankokoiseen etumerkittyyn arvoon</a> verrattuna.<br></p><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
    // Signed integers - etumerkityt arvot, positiiviset tai negatiiviset arvot käy<br>    // esim. i32 - arvot väliltä -2147483648 ja 2147483647 sallittuja<br>
    <span class="" style="color: rgb(125, 159, 211);">let </span>arvo_1: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= -42;         // Esimerkki negatiivisesta arvosta
    <span class="" style="color: rgb(125, 159, 211);">let </span>arvo_2: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= 42; // Esimerkki positiivisesta arvosta

    // Unsigned integers - ei-etumerkityt arvot, vain positiiviset arvot käy<br>    // esim. u32 - arvot väliltä 0 ja 4294967295 sallittuja
    <span class="" style="color: rgb(125, 159, 211);">let </span>arvo_3: <span class="" style="color: rgb(125, 159, 211);">u32 </span>= 42;        // Esimerkki positiivisesta arvosta
    // let invalid: <span class="" style="color: rgb(51, 51, 51);">u32 </span>= -42;     // Tämä ei toimi, unsigned ei voi olla negatiivinen
}<br></pre><pre><br></pre><p><strong>Float tyyppiä </strong>on kahta kokoa:</p><ul><li>32bit</li><li>64bit</li></ul>Nekin määritellään vastaavasti:<br><pre><span class="" style="color: rgb(125, 159, 211);">let </span>liukuluku: f32 = 2.345;<br><br><span class="" style="color: rgb(125, 159, 211);">let </span>liukuluku: f64 = 2.345678;</pre><br><strong><span>Boolean-tyyppi</span> </strong>on joko true tai false:<br><br><pre><span class="" style="color: rgb(125, 159, 211);">let </span>boolean_arvo = true;<br><span class="" style="color: rgb(125, 159, 211);">let </span>boolean_arvo_2: <span class="" style="color: rgb(125, 159, 211);">bool </span>= false; // explisiittisellä tyyppi-merkinnällä<br><br></pre><p><span><strong><span><span><span>Character-tyypp</span>i</span></span></strong><span><strong><span> </span></strong>voi olla </span><span>yksittäinen merkki, mutta merkki voi tarkoittaa tässä tapauksessa muutakin kuin länsimaista kirjainta - Japania, Koreaa, Kiinaa, emojia, nollaleveydellistä välilyöntiä - kaikki ovat valideja merkkejä Rustissa. Rust käyttää Univode Scalar Value -arvoja. <br></span></span></p><p><span><span>Merkit määritellään single-quotejen,<strong> ' '</strong>, avulla, toisinkuin merkkijonot, jotka käyttävät tupla-lainausmerkkiä, <strong>" "</strong>.<strong> <br></strong></span></span></p><pre><span><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>c = 'z';<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>z = 'Ƶ';<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>emoji = '😻';<br>}</span><strong><br><br></strong></span></span></pre><h5><span><span><strong>Yhdistetyypit</strong></span></span><br><span><span><strong></strong></span></span></h5><p>Yhdistetyyppejä käydään läpi enemmän viikolla 2. Niihin kuuluu:</p><ul><li>Array-tyyppi</li><li>Tuple-tyyppi</li></ul><div><br></div><div><br></div><div><br></div><h4>String ja &amp;str - merkkijono Rustissa</h4><p>Rustissa on sekä String sliceja, sekä String-tyyppi erikseen.</p><p>String tyyppi on käytännöllinen, kun kysytään esimerkiksi käyttäjältä dataa. String slice tarvitsee tiedon, kuinka pitkä annettu arvo tulee olemaan. Tämä ei ole mahdollista kun annetaan käyttäjälle mahdollisuus antaa dataa. Datan kokoa ei voida etukäteen tietää. String slicea ei voi myöskään muokata.<br></p><p>String-tyyppi mahdollistaa dynaamisen datan hallinnan ohjelmaa ajaessa. Data tallennetaan heap-osioon stackin sijaan. Heap-osio on hitaampi tapa käsitellä muistia, mutta se mahdollistaa muuttuvan koon muuttujan, kuten String-tyypin olemassaolon.</p><p>String-tyypin tyyppi on String.</p><p>String slicen tyyppi on &amp;str.<br></p><p><br></p><pre>// String-tyypin luominen
<span class="" style="color: rgb(125, 159, 211);">let </span>oma_stringi = String::from("Tämä on String-tyyppi"); // Dynaaminen merkkijono, luo String-tyypin string-slicestä<br>
// String slicen luominen &amp;str
<span class="" style="color: rgb(125, 159, 211);">let </span>string_slice: &amp;str = &amp;oma_stringi[0..4];             // Viittaa osaan Stringistä (0–3 merkkiä, sisältö on: "Tämä")

// String-slice vakiona
<span class="" style="color: rgb(125, 159, 211);">let </span>vakio_slice: &amp;str = "Tämä on string slice vakiona";  // Tämä on jo slice

// String-tyypin muokkaaminen
<span class="" style="color: rgb(125, 159, 211);">let mut</span> muokattava_string = String::from("Muokattava");
muokattava_string.push_str(" String");                    // Lisätään sisältöä Stringiin<br></pre><p><br></p><p></p>

<h4 dir="ltr">Funktiot</h4>
<div>Rustissa, kuten käytännössä kaikissa ohjelmointikielissä, on funktioita, looppeja, sekä tapoja kysyä syötettä käyttäjältä. Tässä käymme peruskäyttötavat tutuista käsitteistä lävitse esimerkkitiedoston kautta.</div><div><br></div><pre>// Tyhjä esimerkkifunktio</pre><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>esimerkki(parametri_1: <span class="" style="color: rgb(125, 159, 211);">parameterin tyyppi</span>, parametri_2: <span class="" style="color: rgb(125, 159, 211);">parametrin_2_tyyppi</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">palautusarvon_tyyppi </span>{<br>&nbsp;&nbsp;&nbsp; //koodia<br>    palautusarvo<br>}<br></pre><div><br></div><p>Yllä olevasta esimerkkifunktiosta näemme Rust-kielen funktion yleisen rakenteen ja toimintaperiaatteen.</p><p>Rustissa funktio määritellään avainsanalla <strong><span class="" style="color: rgb(125, 159, 211);">fn</span></strong>, jota seuraa funktion nimi. Parametrit määritellään sulkeiden sisällä nimipari-muodossa, jossa parametriin liittyy aina sen tyyppi, erotettuna kaksoispisteellä (<strong>:</strong>). Parametrit erotellaan toisistaan pilkulla (<strong>,</strong>). Funktion palautusarvon tyyppi määritellään nuolella (<strong>-&gt;</strong>) funktion nimen ja parametrilistan jälkeen.</p><p>Rust on vahvasti tyypitetty kieli, joten sekä parametrien että palautusarvon tyypit on aina määriteltävä eksplisiittisesti. Tämä auttaa estämään monia virheitä jo käännösaikana.</p><p>Jos funktiolla on palautusarvo, se ilmoitetaan nuolella (<strong>-&gt;</strong>) ja arvon tyypillä. Kaikilla funktioilla ei ole palautusarvoa, jos funktio esimerkiksi tulostaa annetut arvot tietyllä formatointitavalla.<br></p>Erona moneen muuhun ohjelmointikieleen, funktion viimeinen lauseke (ilman puolipistettä) toimii automaattisesti palautusarvona. Jos funktiossa on puolipiste viimeisessä lausekkeessa, se ei palauta mitään, ja palautusarvona on ( ) (unit-tuple).<br><br>Alla näemme lisää esimerkkejä erilaisista funktioista.<br>Ensimmäinen funktio tulostaa "Testifunktio", ei palauta mitään, eikä ota yhtään parametria.<br><p></p><div><br></div><pre><span>// Funktio, joka tulostaa "Testifunktio"
<span class="" style="color: rgb(125, 159, 211);">fn </span>testifunktio() {
    println!("Testifunktio");
}<br><br></span></pre><p><span>Toinen funktio tulostaa annetun i32 arvon, käyttäen hakasulkeita paikkamerkkinä. Palautusarvoa ei ole.<br></span></p><pre><span>
// Funktio, joka ottaa int-muuttujan ja tulostaa sen formatoituna print-lauseeseen
<span class="" style="color: rgb(125, 159, 211);">fn </span>tulosta_kuvaus(arvo: <span class="" style="color: rgb(125, 159, 211);">i32</span>) {
    println!("Annettu arvo on: {}", arvo);
}<br><br></span></pre><p><span>Kolmas funktio ottaa kaksi i32 arvoa parametrina, summaa ne yhteen tallettaen arvon uuteen muuttujaan, ja printtaa formatoituna annetut luvut sekä niiden summan. Palautusarvoa ei ole.<br></span></p><pre><span>
// Funktio, joka ottaa kaksi int-muuttujaa, summaa ne ja tulostaa summan
<span class="" style="color: rgb(125, 159, 211);">fn </span>tulosta_summa(a: <span class="" style="color: rgb(125, 159, 211);">i32</span>, b: <span class="" style="color: rgb(125, 159, 211);">i32</span>) {
    let summa = a + b;
    println!("Lukujen {} ja {} summa on: {}", a, b, summa);
}<br><br></span></pre><p><span>Neljäs funktio ottaa kaksi liukulukua, f64, su</span><span>mmaa ne yhteen ja palauttaa summan. Palautusarvo on, ja se on tyypiltään f64. Funktion viimeisessä lauseessa ei ole puolipistettä, joten se loppuu siihen, ja automaattisesti palauttaa summatun arvon.</span><span>

</span></p><pre><span>// Funktio, joka ottaa kaksi liukulukua, summaa ne ja palauttaa summan
<span class="" style="color: rgb(125, 159, 211);">fn </span>summaa_liukuluvut(a: <span class="" style="color: rgb(125, 159, 211);">f64</span>, b: <span class="" style="color: rgb(125, 159, 211);">f64</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">f64 </span>{
    a + b
}<br></span></pre>
<p>Pääfunktio löytyy jokaisesta Rust-projektista. Se luodaan myös <em>cargo new</em> komentoa käyttäessä. Olemme määritelleet neljä muuta funktiota, joita kutsumme eri arvoilla. Kun funktiot ovat määritelty, niitä voi kutsua. Pääfunktiossa kutsumme jokaista funktiota järjestyksessä, antaen tarvittavat arvot oikeine tyyppeineen funktioille. Viimeisen funktion kohdalla, sen palauttaessa f64 arvon, tallennamme sen muuttujaan pääfunktiossa ja tulostamme sen käyttäjälle.<br></p><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
    testifunktio();
    tulosta_kuvaus(42);
    tulosta_summa(10, 15);
    <span class="" style="color: rgb(125, 159, 211);">let </span>summa = summaa_liukuluvut(3.14, 2.71);
    println!("Liukuluvut summattuna: {}", summa);
}<br></pre><p><br></p><h4>Loopit</h4><div>Rustissa on perinteisen <a href="https://doc.rust-lang.org/std/keyword.if.html">if</a>-lauseen lisäksi <a href="https://doc.rust-lang.org/std/keyword.loop.html">loop</a>-rakenne, joka on yksinkertaisin looppi, joka rikkoutuu kun käyttäjä kutsuu break-komentoa. Match-rakenne on switch-case rakenteen kaltainen, joka vertaa annettua arvoa,&nbsp; ja palauttaa arvoa vastaavan kohdan. Jos annettu arvo ei ole match-listassa, voidaan määritellä "<strong>_</strong>", joka suoritetaan jos annettua arvoa ei löytynyt match-rakenteesta. <a href="https://doc.rust-lang.org/std/keyword.while.html">while</a>-rakenne on tuttu muista kielistä.<br></div><div><br></div><p><span style="font-weight: normal;"><strong>Match-rakenteesta</strong> on esimerkki alla. Funktio ottaa i32 arvon, ja jos arvo on 1, 2 tai 3, se printtaa kyseisen arvon kohdalla olevan lauseen. Jos arvo on joku muu kuin 1, 2 tai 3, suorittaa funktio "_" kohdalla olevan koodin. Match-funktio on kätevä, kun halutaan tehdä eri asioita perustuen annettuun arvoon. Match-rakennetta voi esimerkiksi käyttää menussa, jossa käyttäjä syöttää mitä hän haluaa tehdä. Match-rakenne suorittaa käyttäjän syötteellä annetun toiminnan.</span><br></p><div><br></div><pre><span style="font-weight: normal;"><div><div>// Match-lauseen käyttö</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>match_funktio(luku: &amp;<span class="" style="color: rgb(125, 159, 211);">mut i32</span>) {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>*luku {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 1 =&gt; println!("Luku on yksi"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 2 =&gt; println!("Luku on kaksi"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 3 =&gt; println!("Luku on kolme"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; _ =&gt; println!("Luku on jotain muuta"), // _ on "catch-all" -haara</div><div>&nbsp; &nbsp; }</div><div>}</div><br></div><br><br></span></pre><p><strong>If-rakenteesta</strong> on esimerkki alla. Funktio ottaa luku-nimiseen muuttujaan kokonaislukuarvon, ja suorittaa koodin if-lauseen ehtojen perusteella.<br><span style="font-weight: normal;"></span></p><pre><span style="font-weight: normal;"><br><div><div>// If-lauseen käyttö</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>if_funktio(luku: &amp;mut i32) {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>*luku &gt; 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on suurempi kuin viisi");</div><div>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else if</span> *luku &lt; 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on pienempi kuin viisi");</div><div>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else </span>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on tasan viisi");</div><div>&nbsp; &nbsp; }</div><div>}</div></div><br><br></span></pre><p><span style="font-weight: normal;"><strong>Loop-rakenne</strong> vastaa while-rakenteen tyyliä joka on tuttu monesta muusta ohjelmointikielestä. Looppia jatketaan, kunnes käyttäjä kutsuu <em>break</em><span>-komentoa. Tämä rikkoo silmukan. Loopin sisällä voi käyttää myös muita rakenteita, kuten if-lausetta, jotta lopettamisehto voidaan varmistaa. Muista, että jokaisessa loopissa kannattaa olla jokin arvo, joka muuttuu kuten alla olevan esimerkin laskuriarvo, johon lisätään joka kierroksella 1. Kun arvo saavuttaa luvun 5, looppi lopetataan. Jos mitään tämänkaltaista ehtoa ei ole, looppi jatkuisi loputtomiiin.</span></span><br><span style="font-weight: normal;"></span></p><pre><span style="font-weight: normal;"><div><div>// Loop-rakenteen käyttö</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>loop_funktio() {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> laskuri = 0;</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">loop </span>{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>laskuri == 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!("Loop päättyy, koska laskuri saavutti arvon {}", laskuri);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">break</span>; // Pysäyttää silmukan</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("Loop-laskuri on: {}", laskuri);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; laskuri += 1; // Kasvatetaan laskuria</div><div>&nbsp; &nbsp; }</div><div>}</div><br></div><br><br></span></pre><p>While-rakenne on samanlainen Rustissa kuin muissa kielissä. While-lausekkeen sisälle tulee ehto, jonka täyttyessä loopin suoritus lopetetaan.<br></p><pre><span style="font-weight: normal;"><br><div><div>// While-rakenteen käyttö</div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>while_funktio(laskuri: &amp;mut i32) {</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">while </span>*laskuri &lt; 5 {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; println!("While-laskuri on: {}", laskuri);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; *laskuri += 1;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; println!("While päättyy, koska laskuri saavutti arvon {}", laskuri);</div><div>}</div></div><br><br></span></pre><p>Huomioi, että if-lausetta, looppia, ja match-rakennetta voidaan käyttää myös funktioiden ulkopuolella vaikkapa main-funktion sisällä. Ne eivät vaadi erillistä funktioita, vaan niitä satuttiin käyttämään funktoiden sisällä esimerkeissä.<br></p><p>Pohdintatehtävä: mieti, mitä ylläolevat funktiot tulostavat, kun niitä kutsutaan alla olevassa main-funktiossa annetulla muuttujalla <em>numero</em><span>, jonka arvo on 3.</span><br></p><pre><span style="font-weight: normal;"><br></span></pre><pre><span><span class="" style="color: rgb(125, 159, 211);"></span><div><div><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</div><div>&nbsp; &nbsp; // Esimerkki match-lauseesta</div><div>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> numero = 3;</div><div>&nbsp; &nbsp; match_funktio(&amp;mut numero);</div><br><div>&nbsp; &nbsp; // Esimerkki if-lauseesta</div><div>&nbsp; &nbsp; numero = 3; // Resetoi numero</div><div>&nbsp; &nbsp; if_funktio(&amp;mut numero);</div><br><div>&nbsp; &nbsp; // Esimerkki loop-rakenteesta</div><div>&nbsp; &nbsp; loop_funktio();</div><br><div>&nbsp; &nbsp; // Esimerkki while-rakenteesta</div><div>&nbsp; &nbsp; numero = 0; // Resetoi numero</div><div>&nbsp; &nbsp; while_funktio(&amp;mut numero);</div><div>}</div></div><br></span></pre><br><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15242"></a><h3>1.4. Syöte käyttäjältä, Option ja Result -tyyppi, expect-funktio</h3><p dir="ltr" style="text-align: left;">Tässä kappaleessa opetellaan kysymään käyttäjältä syötettä, ja parsimaan se tarvittaessa oikeaan muotoon.<br></p><p></p>
<p dir="ltr"><br></p>
<h4 dir="ltr">Syötteen kysyminen</h4><div>Rust-tarjoaa käyttäjän syötteen kysymiseen standardikirjaston työkaluja<br></div><pre><span class="" style="color: rgb(125, 159, 211);">use </span>std::io;<br></pre><p>Tämä rivi tuo Rustin standardikirjaston (<a href="https://doc.rust-lang.org/std/index.html">std</a>) sisällä olevan<code></code><a href="https://doc.rust-lang.org/std/io/index.html#standard-input-and-output"> io-moduulin</a> käyttöön.<br><span><span></span><a href="https://doc.rust-lang.org/std/io/index.html#standard-input-and-output">io</a> </span><span>(</span>input/output) tarjoaa toiminnallisuuksia käyttäjän syötteen lukemiseen (<strong>stdin</strong><span>)</span> ja tulostamiseen (<strong>stdout</strong><span> ja <strong>stderr</strong><span>).</span></span></p><p><span><span>Moduuleita käymme tarkemmin lävitse myöhemmissä osioissa.<br></span></span></p><p><span><span>Käydään alla oleva esimerkkikoodi läpi osio osiolta, jotta saamme käsityksen kuinka peruskomentoja syötteen kysymiseen ja käsittelyyn voidaan io-moduulista käyttää.</span></span></p><pre><span class="" style="color: rgb(125, 159, 211);"><span class="" style="color: rgb(51, 51, 51);">use std::io;</span><br>fn </span>main() {<br>&nbsp;&nbsp;&nbsp; // Kysytään sanaa<br>&nbsp;&nbsp;&nbsp; println!("Anna sana:");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut </span>sana = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>sana).expect("Virhe syötteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let</span> sana = sana.trim(); // Poistetaan rivinvaihdot syötteestä<br>&nbsp;&nbsp;&nbsp; println!("Annoit sanan: {}", sana);<br><br></pre><p>Ensimmäisessä osioissa printtaamme käyttäjälle informatiivisen viestin, mitä haluamme käyttäjältä. Alustamme tyhjän merkkijonomuuttujan, joka on mutable, eli voimme muokata sitä tarvittaessa. <br></p><p>Kysymme käyttäjältä rivin, käyttäen io-moduulin stdin-alimoduulin <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line </a>funktiota.&nbsp; read_line ottaa sisäänsä mutable muuttujan, ja tässä tapauksessa referencen eli viittauksen, joka on verrattavissa esim. pointteriin C++:sta. Referencen tunnistaa "<strong>&amp;</strong><span>" -merkistä ennen muuttujaa, ja liittyy Rustin Ownership-konseptiin, jota käsittelemme viikolla 2. Rivin onnistuneen suorituksen jälkeen käyttäjän antama syöte, joka päättyy siis uuteen riviin tai esimerkiksi komentokehotteessa enter-lyöntiin, on tallennettu muuttujaan <em>kirjain</em><span>.</span><em><br></em></span></p><p>Readlinen perässä on myös yksinkertainen virheenhallintakutsu, <em>expect</em><span>, jota käsittelemme myöhemmin. <br></span></p><p><span>Koska syöte tallennetaan sellaisenaan, pitää syötettä siistiä käyttämällä standardikirjaston <a href="https://doc.rust-lang.org/std/primitive.str.html#method.trim">trim</a>-komentoa. Trim-komento poistaa rivinvaihdot syötteestä.</span></p><p><span>Alla olevassa esimerkkikoodissa tehdään sama kuin äskön, mutta lisäksi käytetään if-lauserakennetta hyödyksi ja kutsumme <a href="https://doc.rust-lang.org/std/primitive.str.html#method.len">len</a>-funktiota standardikirjastosta selvittääksemme syöttikö käyttäjä ennemän kuin yhden merkin.<br></span></p><pre><br>&nbsp;&nbsp;&nbsp; // Kysytään kirjainta<br>&nbsp;&nbsp;&nbsp; println!("Anna kirjain:");<br>&nbsp;&nbsp;&nbsp;<span class="" style="color: rgb(125, 159, 211);"> let mut </span>kirjain = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>kirjain).expect("Virhe syötteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>kirjain = kirjain.trim(); // Poistetaan rivinvaihdot syötteestä<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>kirjain.len() == 1 {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Annoit kirjaimen: {}", kirjain);<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println!("Syötteen pitäisi olla yksi kirjain!");<br>&nbsp;&nbsp;&nbsp; }<br><br></pre><p><span>Seuraavassa osiossa kysymme käyttäjältä kokonaisluvun. Luomme uuden muuttujan, joka on myös String-tyyppiä, kutsumme taas read_line funktiota, annamme parametriksi luomamme muuttujan <em>kokonaisluku</em><span> viittauksen kanssa, ja lopussa on virheenhallintalause, <em>expect</em><span>.<br></span></span></span></p><p><span><span><span>Koska luku tallennettaan String-muuttujaan, pitää luku siistiä. Tässä esimerkissä luomme tätä varten uuden, non-mutable kokonaislukumuuttujan, josta ensin otamme pois rivinvaihdot trim-komennolla ja sitten yritämme muuttaa String-tyypin tekstin tyypiksi i32 standardikirjaston <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">parse</a>-komennolla. Lopussa <em>expect</em><span>-virheenhallintakomento, sekä tulostus.</span></span></span></span></p><p><span><span><span><span>Alempana on samanlainen esimerkki mutta liukuluvulla. Muista, että luvuksi tallentaminen vaatii aina tyypin muuton parse-komentoa käyttäen. Merkille ja merkkijonolle riittää pelkkä trim. Muista käyttää viittauksia sekä mutable-muuttujia.<br></span><em></em></span> </span><em></em></span></p><pre><br>&nbsp;&nbsp;&nbsp; // Kysytään kokonaisluku<br>&nbsp;&nbsp;&nbsp; println!("Anna kokonaisluku:");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> kokonaisluku = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut</span> kokonaisluku).expect("Virhe syötteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>kokonaisluku: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= kokonaisluku.trim().parse().expect("Syöte ei ole kelvollinen kokonaisluku");<br>&nbsp;&nbsp;&nbsp; println!("Annoit kokonaisluvun: {}", kokonaisluku);<br><br>&nbsp;&nbsp;&nbsp; // Kysytään liukuluku<br>&nbsp;&nbsp;&nbsp; println!("Anna liukuluku (esim. 3.14):");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> liukuluku = String::new();<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut</span> liukuluku).expect("Virhe syötteen lukemisessa");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>liukuluku: <span class="" style="color: rgb(125, 159, 211);">f64 </span>= liukuluku.trim().parse().expect("Syöte ei ole kelvollinen liukuluku");<br>&nbsp;&nbsp;&nbsp; println!("Annoit liukuluvun: {}", liukuluku);<br>}<br></pre><pre><br></pre><strong>Match-lause</strong> <strong>s<span>yötteen kanssa<br></span></strong><span><span>Kysyessäsi esimerkiksi lukusyötettä käyttäjältä, kannattaa käyttää match-lausetta simppelin rakenteen hyödyntämiseksi.<br></span></span>Parse palauttaa <em>Result</em><span> -tyypin, joka on hyödyllinen ja yleinen tapa käsitellä dataa Rustissa. Jos jotain dataa on, palautetaan tämä data. Jos löytyy virhe, voidaan tässä esimerkkitapauksessa tulostaa haluamamme virhekoodi: <em>Parsiminen epäonnistui</em><span>. Jos tutkit rakennetta hieman, huomaat, että rakenne vastaa match-lauseen rakennetta. Jos parsiminen onnistui, voi parsed_int-muuttujaa käyttää normaalisti tämän jälkeen.<br>Lisää <a href="https://doc.rust-lang.org/std/result/index.html">Result</a>-tyypistä ja <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">parsesta</a>.<br></span></span><br><div><pre><span class="" style="color: rgb(125, 159, 211);"><span class="" style="color: rgb(51, 51, 51);">use std::io;</span><br>fn </span>main() {</pre><pre>&nbsp; &nbsp; println!("Anna luku: ");</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let mut</span> kayttajan_syote = String::new();</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut</span> kayttajan_syote).expect("Error occurred.");<br><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>parsed_int: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= match kayttajan_syote.trim().parse() {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(152, 202, 62); background-color: rgb(255, 255, 255);">Ok</span>(luku) =&gt; luku, </pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(152, 202, 62);">Err</span>(_) =&gt; {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!("Parsiminen epäonnistui.");</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">return</span>;</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; }</pre><pre>&nbsp; &nbsp; }; &nbsp;<br><br></pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">if </span>parsed_int &lt; 0 {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp;println!("Luku on alle 0.");</pre><pre>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else if </span>parsed_int &gt; 100 {</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on yli 100.");</pre><pre>&nbsp; &nbsp; } <span class="" style="color: rgb(125, 159, 211);">else </span>{</pre><pre>&nbsp; &nbsp; &nbsp; &nbsp; println!("Luku on 0 ja 100 väliltä.");</pre><pre>&nbsp; &nbsp; }</pre><pre>}<br><br><br></pre><h5>Except-komento</h5><div>Rustissa expect on metodi, jota käytetään <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a>- tai <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a>-tyypin kanssa. Se antaa mahdollisuuden käsitellä virheitä yksinkertaisesti. Jos operaatio epäonnistuu,<code> </code><em>expect </em>tulostaa siihen liittyvän virheilmoituksen ja lopettaa ohjelman (eli panikoi).</div><div>Alla näemme esimerkin tiedostonkäsittelystä standardikirjaston moduuleita hyödyntämällä. Yrittäessämme avata tiedostoa, käyttämä <em>expect</em><span>iä kertomaan jos tiedoston avaaminen epäonnistuu.</span></div><div><span>Tiedoston käsittelyä käymme läpi tarkemmin myöhemmässä luvussa.<br></span></div><div><br></div><div><div><pre><span class="" style="color: rgb(125, 159, 211);">use </span>std::fs::File;</pre><pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</pre><pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>file = <span class="" style="color: rgb(239, 69, 64);">File</span>::open("tiedosto.txt").expect("Tiedoston avaaminen epäonnistui!");</pre><pre>&nbsp; &nbsp; println!("Tiedosto avattiin onnistuneesti: {:?}", file);</pre><pre>}</pre><br></div></div><h5>Result ja Option -tyyppi</h5><h5><span style="font-weight: normal;">Result j</span><span style="font-weight: normal;">a Option ovat Rustin erityisiä enum-tyyppejä, joita käytetään turvalliseen virheiden ja vaihtoehtoisten arvojen käsittelyyn. Ne ovat olennainen osa Rustin tapaa välttää "paniikkia" (ohjelman kaatumista, Rustissa panic) ja käyttää tyyppijärjestelmää varmistamaan virheiden asianmukainen hallinta.</span></h5><div><br></div><div><strong>Result</strong></div><div>Result-tyyppiä käytetään ilmaisemaan joko onnistumista tai virhetilaa operaatioissa. Se on määritelty näin:</div><div><br></div><pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Result&lt;T, E&gt; {<br>&nbsp;&nbsp;&nbsp; Ok(T),&nbsp; // Onnistumisen tapauksessa sisältää arvon T<br>&nbsp;&nbsp;&nbsp; Err(E), // Virheen tapauksessa sisältää virheen E<br>}<br></pre><ul><li>T on tyyppi onnistuneelle paluuarvolle</li><li>E on tyyppi virheelle</li></ul><div><br></div><h4>Esimerkki:</h4></div><pre>use std::fs::File;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>tulos = <span class="" style="color: rgb(239, 69, 64);">File</span>::open("olemassa_olematon_tiedosto.txt");<br>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>tulos {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok(tiedosto) =&gt; println!("Tiedosto avattiin onnistuneesti!"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err(virhe) =&gt; println!("Tiedoston avaaminen epäonnistui: {}", virhe),<br>&nbsp;&nbsp;&nbsp; }<br>}</pre><p>Tässä <em>File::open</em> palauttaa <em>Result&lt;File, std::io::Error&gt;</em>. Jos tiedosto löytyy, se palauttaa <em>Ok(File)</em>. Jos tiedostoa ei löydy, se palauttaa <em>Err(std::io::Error)</em>.</p><p><br></p><p><strong>Option</strong><br></p><p>Option-tyyppiä käytetään, kun arvo voi olla olemassa tai puuttua. Se on määritelty näin:</p><pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Option&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp; Some(T), // Kun arvo on olemassa<br>&nbsp;&nbsp;&nbsp; None,&nbsp;&nbsp;&nbsp; // Kun arvo puuttuu&nbsp;</pre><pre>}</pre><p><br></p><ul><li>T on tyyppi, jota Option voi sisältää</li><li>None tarkoittaa, että arvoa ei ole</li></ul><div><br></div><div><strong>Esimerkki:</strong></div><div><pre><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>hae_arvo(indeksi: <span class="" style="color: rgb(125, 159, 211);">usize</span>) -&gt; Option&lt;<span class="" style="color: rgb(125, 159, 211);">i32</span>&gt; {</span></span><br><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>luvut = vec![10, 20, 30];</span></span><br><span><span>&nbsp;&nbsp;&nbsp; luvut.get(indeksi).cloned()</span></span><br><span><span>}</span></span><br><span><span></span></span><br><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span></span><br><span><span>&nbsp;&nbsp;&nbsp; <span class="" style="color: rgb(125, 159, 211);">match </span>hae_arvo(1) {</span></span><br><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Some(arvo) =&gt; println!("Arvo löytyi: {}", arvo),</span></span><br><span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None =&gt; println!("Arvoa ei löytynyt!"),</span></span><br><span><span>&nbsp;&nbsp;&nbsp; }</span></span><br><span><span>}</span></span><strong><span></span></strong><br><strong><span></span></strong></pre><strong><span><br></span></strong></div><div><span><span>Tässä get-metodi palauttaa <em>Option&lt;T&gt;</em>:</span></span></div><ul><li><span><span><span>Jos indeksi on kelvollinen, funktio palauttaa <em>Some(arvo)</em></span></span></span></li><li><span><span><span>Jos indeksi ei ole kelvollinen, se palauttaa <em>None</em>.<br></span></span></span></li></ul><div>Koska annettu indeksi on esimerkissä 1, arvo löytyi, palautusarvo on<em> Some(arvo)</em> ja arvo on 20.</div><div><br></div><div><br></div><div><strong>Unwrap-komento - yksinkertainen tapa saada data ulos Optionista ja Resultista</strong></div><div><em>unwrap()</em> <span>on nopea keino purkaa arvoja ilman ylimääräistä virhekäsittelyä, mutta se on riskialtis produktiokoodissa. Panikointi virhetilanteissa voi johtaa ohjelman odottamattomaan kaatumiseen.</span><strong><br></strong></div><div><strong><br></strong></div><div><pre><span><span><span class="" style="color: rgb(125, 159, 211);">let </span>value: Option&lt;<span class="" style="color: rgb(125, 159, 211);">i32</span>&gt; = 5;</span></span><br><span><span></span><span>println!("Value: {}", value.unwrap()); // Tulostaa: Value: 5</span></span><br><strong></strong></pre><span>unwrap-komentoa voi käyttää match-lauseen sijasta, mutta suositeltavampaa on käyttää esim. match-lausetta</span></div><div><span>unwrap-komentoa voi käyttää kaikkien tyyppien kanssa, jotka palauttavat Result-tai Option-tyypin (esim. File::open)<br></span><strong></strong></div><div><br></div><div><strong>Mikä on Result ja Option -tyypin erot?<br></strong></div><div><span><span><em>Result</em>-tyyppiä käytetään, kun operaatiolla on mahdollisuus epäonnistua ja tarvitset virheen selittämiseen liittyvää tietoa (Err).</span></span></div><div><span><span><em>Option</em>-tyyppiä käytetään, kun arvo saattaa puuttua, mutta virheen syy ei ole tarpeen. <br></span></span></div><div><span><span><br></span></span><strong><span></span></strong></div><div><strong><span><br></span></strong></div><div><strong>M<span><span>ikä hyöty on näiden tyyppien käyttämisestä?</span></span></strong></div><div><span><span><span><span><em>Result</em>- ja <em>Option</em>-tyypin käyttö auttaa välttämään null-viitteitä - Optionin <em>None </em>korvaa monesta kielestä tutun null arvon.</span></span></span></span></div><div><span><span><span><span>Nämä tyypit myös varmistavat, että käsittelet virheet eksplisiittisesti.<br></span></span></span></span><strong><span><span><span></span></span></span></strong></div><div><strong><span><br></span></strong></div><div><strong><span><br></span></strong></div><div><strong>M<span><span>ikä &lt;T&gt;?</span></span></strong></div><div><span><span><span><span><em>&lt;T&gt;</em> on Rustissa generinen tyyppiparametri, jota käytetään tekemään funktioista, rakenteista, metodeista tai enumeista tyypistä riippumattomia. Geneerisyys mahdollistaa sen, että voit kirjoittaa yleiskäyttöistä koodia, joka toimii eri tyyppien kanssa ilman, että sinun tarvitsee toistaa samaa koodia jokaiselle tyypille erikseen.<br></span></span></span></span></div><div><strong><span><span><span><span><br></span></span></span></span></strong></div><div><strong><span><span><span><span><br></span></span></span></span></strong></div><div><strong><span><span><span><span>Miten geneerinen tyyppi toimii?</span></span></span></span></strong><span><span><span><span><p><em>&lt;T&gt;</em> toimii kuin <span>paikkamerkkinä tyypille </span>, joka päätetään myöhemmin – joko koodin kutsun yhteydessä tai kääntäjän päättelyn avulla. Rustissa geneerinen tyyppi on aina tarkasti määritelty käännösvaiheessa, joten ohjelma ei sisällä ylimääräistä suoritusajan ylikuormaa geneerisyydestä. Rustissa kääntäjä luo geneerisestä koodista erilliset toteutukset kaikille tarvittaville tyypeille (prosessia kutsutaan <strong>monomorfisoinniksi</strong>). Tämä tarkoittaa, että generics tarjoaa sekä suorituskyvyn että joustavuuden ilman kompromisseja tyyppiturvassa.<strong> </strong>Tämä aihe menee tarkemmin jo lisätietona, mutta sisällytettiin tiedoksi <em>Option</em>-tyypin ja <em>Result</em>-tyypin takia - nämä tyypit käyttävät geneeristä arvoa T, jotta käyttäjä voi käyttää näissä mitä tyyppiä tahansa.<strong><br></strong></p><p><span><span>Geneerisistä tyypeistä lisää Rustin kirjan kappaleessa 10</span></span><strong><span>.</span></strong></p><p><span><span>Option ja Result tyypistä lisää kappaleessa 6.</span></span></p><p><span><span><br></span></span></p></span></span></span></span></div><div><br></div><code></code><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15243"></a><h3>1.5. use-komento</h3><p dir="ltr" style="text-align: left;"></p><h4>use-komento</h4><div><p>Rustissa avainsana <em>use </em>on osa 
moduulijärjestelmää, ja sitä käytetään tuomaan nimiä (kuten funktioita, 
rakenteita, enumeja tai traitteja) käyttöön toisista moduuleista tai 
kirjastoista. Tämä tekee koodista helpommin luettavaa ja välttää tarpeen
 kirjoittaa pitkiä nimiavaruuksia toistuvasti.</p><p><br></p><h4>use-avainsanan esimerkki<br></h4><pre>use std::fs::File;<br>use std::io::{self, Read};<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() -&gt; <span class="" style="color: rgb(239, 69, 64);">io</span>::Result&lt;()&gt; {<br>    // Avataan olemassa oleva tiedosto<br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> tiedosto = <span class="" style="color: rgb(125, 159, 211);">match </span><span class="" style="color: rgb(239, 69, 64);">File</span>::open("esimerkki.txt") {<br>        Ok(file) =&gt; file,<br>        Err(e) =&gt; {<br>            eprintln!("Virhe avattaessa tiedostoa: {}", e);<br>            return Err(e);<br>        }<br>    };<br><br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> sisältö = String::new();<br><br>    // Luetaan tiedoston sisältö merkkijonoksi<br>    <span class="" style="color: rgb(125, 159, 211);">match </span>tiedosto.read_to_string(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>sisältö) {<br>        Ok(_) =&gt; println!("Tiedoston sisältö:\n{}", sisältö),<br>        Err(e) =&gt; {<br>            eprintln!("Virhe luettaessa tiedostoa: {}", e);<br>            return Err(e);<br>        }<br>    }<br><br>    Ok(())<br>}<br><br></pre><p>Esimerkkitiedostomme:</p><pre><img src="data/kuva%20%281%29.png" alt="" role="presentation" class="img-fluid"><br><br></pre><p>Esimerkki-ajo:</p><pre>Tiedoston sisältö:<br>Esimerkki<br>tekstiä<br>tänne!</pre></div>Rustin <a href="https://doc.rust-lang.org/std/fs/index.html">std::fs</a> -moduuli tarjoaa kaikki tarvittavat työkalut sekä tiedostojen lukemiseen että kirjoittamiseen.&nbsp; Kun käyttämä use-avainsanaa, voimme tuoda fs-moduulin tarjoamia moduuleita käyttöömme. Esimerkiksi:<br><pre>use std::io::{self, Read};</pre>tuo std-kirjaston osia käyttöömme.<br><br><h3>Osat:</h3><ol><li><p><strong><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code></strong><span class="" style="color: rgb(51, 51, 51);">:</span></p><ul><li><strong><code><span class="" style="color: rgb(51, 51, 51);">std</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>on Rustin standardikirjasto.</span></li><li><strong><code><span class="" style="color: rgb(51, 51, 51);">io</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>on standardikirjaston moduuli, joka tarjoaa syöte- ja tulostetoimintoja, kuten kirjoittamista, lukemista ja virheenkäsittelyä.</span></li></ul></li><li><p><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>self</strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p><ul><li><strong><code><span class="" style="color: rgb(51, 51, 51);">self</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>viittaa siihen, että koko </span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code><span class="" style="color: rgb(51, 51, 51);">-moduuli tuodaan käyttöön sellaisenaan.</span></li><li><span class="" style="color: rgb(51, 51, 51);">Tämän ansiosta voit käyttää esimerkiksi </span><code><span class="" style="color: rgb(51, 51, 51);">io::Result</span></code><span class="" style="color: rgb(51, 51, 51);">, </span><code><span class="" style="color: rgb(51, 51, 51);">io::Error</span></code><span class="" style="color: rgb(51, 51, 51);">, tai muita </span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code><span class="" style="color: rgb(51, 51, 51);">-moduulin ominaisuuksia suoraan ilman pitkää nimeä </span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code><span class="" style="color: rgb(51, 51, 51);">.</span></li></ul></li><li><p><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>Write</strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p><ul><li><span class="" style="color: rgb(51, 51, 51);">Tämä tuo </span><code><span class="" style="color: rgb(51, 51, 51);">Write</span></code><span class="" style="color: rgb(51, 51, 51);">-traitin käyttöön, joka tarjoaa ominaisuudet tiedon kirjoittamiseen. Esimerkiksi:</span><ul><li><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>write</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Kirjoittaa raakadataa.</span></span></li><li><code><span class="" style="color: rgb(51, 51, 51);"><strong>write_all</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Kirjoittaa kaiken annetun datan.</span></li><li><code><span class="" style="color: rgb(51, 51, 51);"><strong>writeln!</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Makro, joka kirjoittaa tekstirivin ja lisää rivinvaihdon.</span></li></ul></li><li><code><span class="" style="color: rgb(51, 51, 51);"><strong>Write</strong></span></code><span class="" style="color: rgb(51, 51, 51);">-traitia tarvitaan tiedostoihin kirjoittamisessa tai tulosteiden ohjaamisessa.</span></li></ul></li><li>
        <p><span><code><span><strong><span class="" style="color: rgb(51, 51, 51);">Read</span></strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p>
        <ul>
            <li><span><span class="" style="color: rgb(51, 51, 51);">Tämä tuo </span><span><code><span class="" style="color: rgb(51, 51, 51);">Read </span></code></span><span class="" style="color: rgb(51, 51, 51);">traitin käyttöömme, joka tarjoaa ominaisuudet tiedon lukemiseen tiedostosta. Esimerkiksi:</span></span><ul>
                    <li><span><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Lukee raakadataa tavuina.</span></span></li>
                    <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read_to_string</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Lukee annetun datan String-muotoon.</span></li>
                    <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read_exact</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Lukee annetun määrän tavuja annetusta datasta.</span></li>
                </ul>
            </li>
            <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">Read</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">-traitia tarvitaan tiedostojen lukuun.</span></li></ul></li></ol>Käyttämällä <em>use</em>-lausetta voimme pitää koodin siistinä ja helposti luettavana.<br>Traiteistä lisää kirjan kappaleessa 10.<br><p></p></div><a href="#toc">&uarr; top</a>
</body>
</html>