<!doctype html>
<html>
<head>
    <title>3_Fundamentals of Rust</title>
    <meta charset="utf-8">
    
</head>
<body>
<a name="top"></a><h1>Fundamentals of Rust</h1><p class="book_summary"><p dir="ltr" style="text-align: left;">In the first part, we go through useful documentation pages, the benefits and advantages of Rust, and information about Rust in general.<br><br>The following paragraphs discuss the basic commands of the cargo tool, mutable and immutable variables, printing, taking input from the user.</p></p><div class="book_toc_numbered"><a name="toc"></a><h2 class="text-center pb-5">Table of contents</h2><ul><li><a title="1. Fundamentals of Rust" class="font-weight-bold text-decoration-none" href="#ch15244">1. Fundamentals of Rust</a><ul><li><a title="1.1. Cargo commands" class="text-decoration-none" href="#ch15245">1.1. Cargo commands</a></li><li><a title="1.2. Variables and printing" class="text-decoration-none" href="#ch15246">1.2. Variables and printing</a></li><li><a title="1.3. Types, Functions, Loops" class="text-decoration-none" href="#ch15247">1.3. Types, Functions, Loops</a></li><li><a title="1.4. Input from the user, Option and Result type, expect-function" class="text-decoration-none" href="#ch15248">1.4. Input from the user, Option and Result type, expect-function</a></li><li><a title="1.5. use-command" class="text-decoration-none" href="#ch15249">1.5. use-command</a></li></ul></li></ul></div><div class="book_chapter"><a name="ch15244"></a><h2>1. Fundamentals of Rust</h2><p dir="ltr" style="text-align: left;"></p><h4>What is Rust?</h4>Rust is a new, low-level, high-performance and secure programming language. The development of Rust started already in 2006, and the sponsorship of the project's development started by Mozilla in 2009. Rust is used in applications that require efficiency and security, because it is on the same level as C and C++ languages ​​in terms of speed. C-based languages ​​are unreliable when it comes to memory management, because the user is given a lot of power in memory management, which is one of the reasons why memory management causes a large part of, for example, information security problems in these languages.<br><br>Rust is already used by many companies, from startups to large companies such as Firefox (owned by Mozilla), Dropbox and Cloudflare. Rust is used, for example, in command prompt applications, embedded systems, web applications and WebAssembly. Rust's advantages due to safe memory management, developer-loved syntax and community, and competitive performance are the reasons why the Rust programming language has held its ground, especially in certain areas of programming.<br><br><br><h4>Biggest benefits of Rust</h4>As a language, Rust has two things that are not found in other languages, which also make it more difficult to learn: Ownership, and Lifetime.<br>Ownership is related to memory management, and is also one of the reasons for Rust's efficiency - Rust does not have an automatic garbage collector like Java, for example, but memory is managed automatically through the Ownership method.<br>Lifetime is a concept related to how long a variable is kept in memory during program execution.<br>Since the memory management is automatic, the user can focus more on programming and think less about possible error points. Rust also drives programmers to program in a way where error handling is done in the program using, for example, Result and Option types. All of these contribute to writing programs where memory management errors are rapidly reduced, but the efficiency remains at the level of other fast programming languages.<h4><br></h4><h4>Useful documentation sites</h4>This course has documentation in Finnish and English about the things covered in the course, but the documentation also tells you which chapter of Rust's English book you can find additional information on. The documentation page of Rust's standard library is also used when additional information is given about the use of a function - it is good to use these pages together with the learning material.<br>Rust also has its own Rust By Example page, where you can find practical examples of many Rust commands.<br><br>Rust By Example: <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">https://doc.rust-lang.org/stable/rust-by-example/index.html</a><br><br><p>Rust's own book: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></p><p>Rust's documenation page for the standard library: <a href="https://doc.rust-lang.org/stable/std/index.html">https://doc.rust-lang.org/stable/std/index.html</a></p><br><p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15245"></a><h3>1.1. Cargo commands</h3><p dir="ltr" style="text-align: left;">After installing Rust and its tools, you are ready to make your first project using the cargo tool.</p><h4>What is cargo?</h4>Cargo is Rust's package manager and build tool. Cargo can do many tasks for you, such as compiling the program, loading additional libraries defined in your program and compiling these libraries.<br>You can check from the command prompt/terminal whether cargo is loaded with the command:<pre>cargo --version</pre><p>If the version is not displayed but an error code is received, see the <strong>installation instructions</strong> for your operating system again.</p><p><br></p><h4>Basic commands</h4>One of Cargo's basic functions is project creation. Project can mean e.g. in the case of this course, one weekly assignment, because different weekly assignments may have different libraries in use, and the assignments of the weekly assignments are different from each other. It is recommended that you make a separate project for each weekly task.<br><br>A new project can be created with the command:<pre>cargo new projektin_nimi --bin</pre><p><span>The cargo new command creates a new project with the name you give. The --bin parameter makes the program executable from a project, instead of a library. Cargo creates a folder called project_name - the name you give - containing several files.</span></p><p>The most important files for now are Cargo.toml, which is at the root level of the folder, and the main.rs file in the src folder. Rust files end in rs.</p><p><br></p><h4>Cargo.toml file content:</h4><pre>[package]<br>name = "project_name"<br>version = "0.1.0"<br>authors = ["student"]<br>[dependencies]<br><br></pre><div>The Cargo.toml file contains information about the project. It is based on TOML (Tom's Obvious, Minimal Language) format.</div><div><br></div><h4>Use of external libraries</h4><div>If your program uses external libraries - which are used in several different ways in this course - you should add the necessary libraries under [dependencies] in the Cargo.toml file of the weekly assignment project. Below is an example of using the <a href="https://docs.rs/rand/latest/rand/">rand</a> library in a project:</div><div><br></div><div><pre>[dependencies]<br>rand = "0.8.5"<br><br></pre><p>When the user adds the library to the Cargo.toml file and the project uses it, with the next build command or run command, cargo knows how to translate the library into an executable form so that the commands it brings can be used. The file defines which version of the library is found. The latest available version can be found in the library documentation.</p><p><br></p><h4>Building a project and running it:</h4>While inside the project folder, the project can be built using the command:</div><pre>cargo build</pre>The above command will compile your program into executable form.<br>Executable files are created in the target folder. At the same time, cargo creates the file Cargo.lock, which keeps track of the exact version numbers used in the project. Sometimes the library you use may use other libraries within it, which appear in the Cargo.lock file. You don't need to touch this file yourself, because cargo handles this automatically.<br><br>Cargo can compile and run your project while inside the project folder, with the command:<pre>cargo run<br></pre>If the files have changed since the last program run, cargo will compile the files again and then run your program.<br><br>By using the <em>new</em>, <em>run </em>and <em>build </em>commands, you can already get far with using cargo.<p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15246"></a><h3>1.2. Variables and printing</h3><p dir="ltr" style="text-align: left;"></p>In this chapter, we learn about Rust's variables and printing/output.<p></p>

<h4 dir="ltr" style="text-align: left;">Variables</h4>
<div>Rust, like practically all programming languages, has variables. The use of variables in Rust differs from many languages ​​because of Rust's <em>ownership </em>feature. In many other languages, variables are default mutable - that is, their values ​​can be changed. In Rust, it's the other way around.</div>
<div><span><br></span></div>
<div><span>In order to change the value of a variable in Rust, you have to give it <em>mut </em><span>keyword as </span>additional information. mut that means "<a href="https://www.suomisanakirja.fi/englanti/mutable">mutable</a>". <br></span></div>
<div><span><br></span></div>
<div><span>Example of Rust's immutable variable and mutable variable:</span>
    <pre><span>   <span class="" style="background-color: rgb(255, 255, 255); color: rgb(255, 255, 255);"> <span class="" style="color: rgb(125, 159, 211);">let</span></span> x = 5;       // immutable variable
    // x = 10;       // This would give an error, because x is immutable

    <span class="" style="color: rgb(125, 159, 211);">let </span><span class="" style="color: rgb(125, 159, 211);">mut </span>y = 10;  // mutable variable
    y = 20;           // This is allowed, because y is mutable</span><span></span></pre>

</div>
<br>

<p><span>If the user tries to edit a variable that has not been marked as editable, Rust will issue an error code. In the example above, we see what is allowed and what is not. The // entry means a comment line, i.e. that line is not executed in the program. For example, the <em>x = 10</em> is commented because we are trying to change a variable that is not mutable, so Rust would not allow the program to be compiled but would give an error code.</span></p>
<p><span><br></span></p>
<h4>Printing</h4>Like many other programming languages, Rust offers a way to print text to the command prompt. You can print the text you control inside quotation marks, enter one or more variables inside square brackets in the sentence to be printed, use square brackets as a placeholder and list the versions, the variables remain after the comma. Below are examples of the appropriate use of the print function.<br>Note! Calculations performed with variables do not change the original value, so the use of a variable value is not necessary in the example printouts:<br><br>
<div>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(51, 51, 51); background-color: rgb(255, 255, 255);">println</span>!("Hey, I'm studying Rust!");</pre>
    <pre><br></pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let</span> name = "Matti";</pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(51, 51, 51);">println!</span>("Name is: {name}");</pre>
    <pre><br></pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>number = 5;</pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>multiplied = number * 2;</pre>
    <pre>&nbsp; &nbsp; println!("Number: {number}, multiplied: {multiplied}");</pre>
    <pre><br></pre>
    <pre>&nbsp; &nbsp; <span class="" style="background-color: rgb(255, 255, 255); color: rgb(125, 159, 211);">let </span>a = 3;</pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>b = 4;</pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>c = a * a + b * b;</pre>
    <pre>&nbsp; &nbsp; println!("Hypotenuse: {c}");</pre>
    <pre><br></pre>
    <pre>&nbsp; &nbsp; <span class="" style="background-color: rgb(255, 255, 255); color: rgb(125, 159, 211);">let </span>name = "Matti";</pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>age = 30;</pre>
    <pre>&nbsp; &nbsp; println!("Name: {}, Age: {}", name, age);</pre>
    <pre><br></pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>name = "Rust";</pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>version = "1.64";</pre>
    <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>result = 42;</pre>
    <pre>&nbsp; &nbsp; println!("Welcome to {} with  version {}! Result: {}", name, version, result);</pre>
    <div><br></div>
    <div><br></div>
    <div>
        <h4>Running the example program</h4>If you want to run the example code above, remember that Rust must always have a main function. After creating the project with the cargo new command, put the above example program inside the main function.</div><div><br></div>
    <pre><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span></pre>
    <pre><span>    // example program here</span></pre>
    <div>
        <p><span></span></p>
        <pre><span>    println</span>!("Hey, I'm studying Rust!");<br>    etc...<br>}</pre>
        <p></p>
        <pre><span><pre><br></pre></span></pre>
        <h5><strong>Example program output</strong></h5>
    </div>
    <pre>Hey, I'm studying Rust!<br>Name is: Matti<br>Number: 5, multiplied: 10<br>Hypotenuse: 25<br>Name: Matti, Age: 30<br>Welcome to Rust with version 1.64! Result: 42</pre>
    <div><br></div>
    <div><br></div>
</div></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15247"></a><h3>1.3. Types, Functions, Loops</h3><p dir="ltr"></p>In this section, we familiarize ourselves with Rust's equivalents of general programming concepts.<br><br>
<h4>Rust's variable types</h4>There are several types of rust. Since Rust is a <a href="https://en.wikipedia.org/wiki/Type_system#Static_type_checking">statically typed</a> language, it must know all types at the compile time of the program before the program is executed. The types are separately divided into scalars - single values ​​- and compound types.<br><br>
<div><br></div>
<div><strong>Defining a variable:</strong></div>
<pre><span class="" style="color: rgb(125, 159, 211);">let </span>variable_name: variable type = variable_value;<br></pre>
<p>The <a href="https://doc.rust-lang.org/std/keyword.let.html">let</a> keyword enables variable creation. The variable name comes after the let keyword. The type of the variable is followed by the colon, followed by the value of the variable after the = sign. The type of the variable can be an individual type, a list of individual types, or, for example, an instance of a struct - more about structs in later weeks.</p><br>
<h5>Scalar types</h5>
<p>There are four scalar types:</p>
<ul>
    <li>
        <p>Int</p>
    </li>
    <li>
        <p>Float</p>
    </li>
    <li>
        <p>Boolean</p>
    </li>
    <li>
        <p>Character</p>
    </li>
</ul>
<p><strong>Int-types</strong><span> exist in different sizes:</span><strong><br></strong></p>
<ul>
    <li>
        <p>8bit</p>
    </li>
    <li>
        <p>16bit</p>
    </li>
    <li>
        <p>32bit</p>
    </li>
    <li>
        <p>64bit</p>
    </li>
</ul>
<div><br></div>The different sizes of the int type are defined for example:<pre><span class="" style="color: rgb(125, 159, 211);">let</span> number: i8 = 5;</pre>
<pre><span class="" style="color: rgb(125, 159, 211);">let </span>number_2: i32 = 10000;<br><br></pre>
<p><strong>Int types </strong><span>can also be only positive, or both positive and negative. If only positive values ​​are allowed, the <a href="https://doc.rust-lang.org/std/u32/constant.MAX.html">maximum value</a> is practically doubled compared to a <a href="https://doc.rust-lang.org/std/i32/constant.MAX.html">signed value of the same size</a>.</span></p>
<pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
    // Signed integers - signed values, positive or negative values ​​will do<br>    // e.g. i32 - values ​​between -2147483648 and 2147483647 allowed<br>
    <span class="" style="color: rgb(125, 159, 211);">let </span>value_1: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= -42;         // An example of a negative value
    <span class="" style="color: rgb(125, 159, 211);">let </span>value_2: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= 42; // An example of a positive value

    // Unsigned integers - non-signed values, only positive values allowed<br>    // e.g. u32 - values ​​between 0 and 4294967295 are allowed
    <span class="" style="color: rgb(125, 159, 211);">let </span>value_3: <span class="" style="color: rgb(125, 159, 211);">u32 </span>= 42;        // An example of a positive value
    // let invalid: <span class="" style="color: rgb(51, 51, 51);">u32 </span>= -42;     // This wont work, unsigned integer cannot be negative
}<br></pre>
<pre><br></pre>
<p><strong>Float type </strong>has two sizes:</p>
<ul>
    <li>32bit</li>
    <li>64bit</li>
</ul>They are defined accordingly:<pre><span class="" style="color: rgb(125, 159, 211);">let </span>float_number: f32 = 2.345;<br><br><span class="" style="color: rgb(125, 159, 211);">let </span>float_number_2: f64 = 2.345678;</pre><br><strong><span>Boolean-type</span> </strong>is either true or false:<br><br>
<pre><span class="" style="color: rgb(125, 159, 211);">let </span>boolean_value = true;<br><span class="" style="color: rgb(125, 159, 211);">let </span>boolean_value_2: <span class="" style="color: rgb(125, 159, 211);">bool </span>= false; // with explicit type<br><br></pre>
<p><span><strong><span><span><span>Character-type </span></span></span></strong><span><span><span><span>can be a single character, but in this case the character can mean something other than a western character - Japan, Korea, China, emoji, zero-width space - all are valid characters in Rust. Rust uses Univode Scalar Values.</span></span></span></span><span><br></span></span></p>
<p><span><span>Characters are defined using single-quotes, ' ', unlike strings, which use double-quotes, " ".<strong><br></strong></span></span></p>
<pre><span><span><span><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>c = 'z';<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>z = 'Ƶ';<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>emoji = '😻';<br>}</span><strong><br><br></strong></span></span></pre>
<h5><span><span><strong>Combined types</strong></span></span><span><span><strong></strong></span></span></h5>
<p>More compound types will be covered in week 2. They include:</p>
<ul>
    <li>Array-type</li>
    <li>Tuple-type</li>
</ul>
<div><br></div>
<div><br></div>
<div><br></div>
<h4>String and &amp;str - string in Rust</h4>Rust has both String slices and the String type separately.<br><br>The String type is practical when, for example, asking the user for data. String slice needs information on how long the given value will be. This is not possible when giving the user the option to provide data. The size of the data cannot be known in advance. String slice cannot be edited either.<br><br>The String type enables dynamic data management while running the program. Data is stored in the heap section instead of the stack. The Heap partition is a slower way to deal with memory, but it allows a variable of variable size to exist, such as a String type.<br><br>The type of the String type is String.<br><br>The type of string slice is &amp;str.<p><br></p>
<pre>// Creating a String type<br><span class="" style="color: rgb(125, 159, 211);">let </span>own_string = String::from("This is of type String"); // Dynamic string, create String type from string-slice<br><br>// Creating a String slice &amp;str<br><span class="" style="color: rgb(125, 159, 211);">let </span>string_slice: &amp;str = &amp;own_string[0..4];             // Refers to part of String (0-3 characters, content is: "This")<br><br>// String-slice as standard<br><span class="" style="color: rgb(125, 159, 211);">let </span>standard_slice: &amp;str = "This is a string slice standard";  // This is already a slice<br><br>// Modifying the String type<br><span class="" style="color: rgb(125, 159, 211);">let </span>mut editable_string = String::from("Editable");<br>editable_string.push_str(" String");                    // Add content to String</pre>
<p><br></p>
<p></p>

<h4 dir="ltr">Functions</h4>
<div>Rust, like practically all programming languages, has functions, loops, and ways to ask for input from the user. Here we go through the basic usage of familiar concepts through an example file.</div>
<div><br></div>// Empty example function<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>example(parameter_1: <span class="" style="color: rgb(125, 159, 211);">parameter_type</span>, parameter_2: <span class="" style="color: rgb(125, 159, 211);">parameter_2_type</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">return_value_type </span>{<br>&nbsp;&nbsp;&nbsp; //code<br>&nbsp;&nbsp;&nbsp; return value<br>}<div><br></div>From the example function above, we can see the general structure and operating principle of a Rust language function.<br><br>In Rust, a function is defined with the fn keyword followed by the function name. Parameters are defined inside parentheses in the form of a name pair, where the parameter is always accompanied by its type, separated by a colon (:). Parameters are separated by a comma (,). The type of the function's return value is defined by an arrow (-&gt;) after the function name and the parameter list.<br><br>Rust is a strongly typed language, so the types of both the parameters and the return value must always be defined explicitly. This helps prevent many errors already at compile time.<br><br>If the function has a return value, it is indicated by an arrow (-&gt;) and the type of the value. Not all functions have a return value if, for example, the function only prints the given parameter values ​​with a certain formatting method.<br>Unlike many other programming languages, the last expression of the function (without the semicolon) automatically serves as the return value. If the function has a semicolon in the last expression, it returns nothing, and the return value is ( ) (unit-tuple).<br><br>Below we see more examples of different functions.<br>The first function prints "Test function", returns nothing, and takes no parameters.<p></p>
<div><br></div>
<pre><span>// Function that prints "Test Function"<br><span class="" style="color: rgb(125, 159, 211);">fn </span>test_function() {<br>    println!("Test function");<br>}<br><br></span></pre>
<p><span>The second function prints the given i32 value, using square brackets as placeholders. There is no return value.</span></p>
<pre><span>
// A function that takes an int variable and prints it formatted in a print statement<br><span class="" style="color: rgb(125, 159, 211);">fn </span>print_description(value: <span class="" style="color: rgb(125, 159, 211);">i32</span>) {<br>    println!("The given value is: {}", value);<br>}<br><br></span></pre>
<p><span>The third function takes two i32 values ​​as a parameter, sums them together, storing the value in a new variable, and prints the given numbers and their sum as formatted. There is no return value.</span></p>
<pre><span>
// A function that takes two int variables, sums them, and prints the sum<br><span class="" style="color: rgb(125, 159, 211);">fn </span>print_sum(a: <span class="" style="color: rgb(125, 159, 211);">i32</span>, b: <span class="" style="color: rgb(125, 159, 211);">i32</span>) {<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>sum = a + b;<br>    println!("The sum of numbers {} and {} is: {}", a, b, sum);<br>}</span></pre>
<p><span>The fourth function takes two floating point numbers, f64, adds them together and returns the sum. The return value is and is of type f64. There is no semicolon in the last statement of the function, so it ends there, and automatically returns the summed value.</span><span></span></p>
<pre><span>// A function that takes two floating point numbers, sums them, and returns the sum<br><span class="" style="color: rgb(125, 159, 211);">fn </span>sum_float(a: <span class="" style="color: rgb(125, 159, 211);">f64</span>, b: <span class="" style="color: rgb(125, 159, 211);">f64</span>) -&gt; <span class="" style="color: rgb(125, 159, 211);">f64 </span>{<br>    a + b<br>}</span></pre>
<p>The main function can be found in every Rust project. It is also created using the cargo new command. We have defined four other functions that we call with different values. Once the functions are defined, they can be called. In the main function, we call each function in order, giving the necessary values ​​with the correct types to the functions. For the last function, when it returns the value of f64, we store it in a variable in the main function and print it to the user.</p>
<pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {
    test_function();
    print_description(42);
    print_sum(10, 15);
    <span class="" style="color: rgb(125, 159, 211);">let </span>total_sum = sum_float(3.14, 2.71);
    println!("Floats summed together: {}", total_sum);
}<br></pre>
<p><br></p>
<h4>Loops</h4>In addition to the traditional <a href="https://doc.rust-lang.org/std/keyword.if.html">if statement</a>, Rust has a <a href="https://doc.rust-lang.org/std/keyword.loop.html">loop structure</a>, which is the simplest loop that breaks when the user calls the break command. The match structure is similar to the switch-case structure, which compares the given value and returns the item corresponding to the value. If the given value is not in the match list, "_" can be defined, which is executed if the given value was not found in the match structure. The <a href="https://doc.rust-lang.org/std/keyword.while.html">while structure</a> is familiar from other languages.<br><br>An example of the <strong>match structure</strong> is shown below. The function takes the value of i32, and if the value is 1, 2 or 3, it prints the statement at that value. If the value is something other than 1, 2, or 3, the function executes the code at "_". The match function is handy when you want to do different things based on the given value. For example, the Match structure can be used in a menu where the user enters what he wants to do. The match structure performs the action given by the user input.<div><br></div>
<pre><span style="font-weight: normal;"><div>// Using the match statement<br><span class="" style="color: rgb(125, 159, 211);">fn </span>match_function(number: &amp;<span class="" style="color: rgb(125, 159, 211);">mut </span><span class="" style="color: rgb(125, 159, 211);">i32</span>) {<br>    match *number {<br>        1 =&gt; println!("Number is one"),<br>        2 =&gt; println!("Number is two"),<br>        3 =&gt; println!("The number is three"),<br>        _ =&gt; println!("Number is something else"), // _ is a "catch-all" branch<br>    }<br>}</div><br><br></span></pre>
<p><span>An example of the </span><strong>if structure </strong><span>is shown below. The function takes an integer value into the variable named number, and executes the code based on the conditions of the if statement.</span><span style="font-weight: normal;"></span></p>
<pre><span style="font-weight: normal;"><br><div>// Using the if statement<br><span class="" style="color: rgb(125, 159, 211);">fn </span>if_function(number: &amp;<span class="" style="color: rgb(125, 159, 211);">mut i32</span>) {<br>    <span class="" style="color: rgb(125, 159, 211);">if </span>*number &gt; 5 {<br>        println!("The number is greater than five");<br>    } <span class="" style="color: rgb(125, 159, 211);">else if</span> *number &lt; 5 {<br>        println!("The number is less than five");<br>    } <span class="" style="color: rgb(125, 159, 211);">else </span>{<br>        println!("The number is exactly five");<br>    }<br>}</div><br><br></span></pre>
<p><span><span>The <strong>loop structure </strong>corresponds to the style of the while structure, which is familiar from many other programming languages. The loop continues until the user calls the break command. This breaks the loop. You can also use other structures inside the loop, such as an if statement, to ensure the termination condition. Remember that every loop should have a value that changes like the counter value in the example below, to which 1 is added every round. When the value reaches 5, the loop is stopped. If there is no such condition, the loop would continue indefinitely.</span></span><span style="font-weight: normal;"></span></p>
<pre><span style="font-weight: normal;"><div>// Using the Loop structure<br><span class="" style="color: rgb(125, 159, 211);">fn </span>loop_function() {<br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> counter = 0;<br>    <span class="" style="color: rgb(125, 159, 211);">loop </span>{<br>        <span class="" style="color: rgb(125, 159, 211);">if </span>counter == 5 {<br>            println!("Loop ends because counter reached {}", counter);<br>            <span class="" style="color: rgb(125, 159, 211);">break</span>; // Stops the loop<br>        }<br>        println!("Loop counter is: {}", counter);<br>        counter += 1; // Increment the counter<br>    }<br>}</div><br><br></span></pre>
<p>The while structure is similar in Rust to other languages. A condition is entered inside the While expression, which, when fulfilled, terminates the execution of the loop.</p>
<pre><span style="font-weight: normal;"><br><div>// Using the while structure<br><span class="" style="color: rgb(125, 159, 211);">fn </span>while_function(counter: &amp;mut i32) {<br>    <span class="" style="color: rgb(125, 159, 211);">while </span>*counter &lt; 5 {<br>        println!("While counter is: {}", counter);<br>        *counter += 1;<br>    }<br>    println!("While ends because counter reached {}", counter);<br>}</div><br><br></span></pre>Note that the if statement, loop, and match structure can also be used outside functions, for example inside the main function. They do not require separate functions, but happened to be used inside functions in the examples.<br><br>Reflection task: think about what the functions above print when they are called with the variable number given in the main function below, the value of which is 3.<pre><span style="font-weight: normal;"><br></span></pre>
<pre><span><span class="" style="color: rgb(125, 159, 211);"></span><div><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>    // Example of a match statement<br>    <span class="" style="color: rgb(125, 159, 211);">let mut </span>number = 3;<br>    match_function(&amp;mut number);<br><br>    // Example of an if statement<br>    number = 3; // Reset the number<br>    if_function(&amp;mut number);<br><br>    // An example of a loop structure<br>    loop_function();<br><br>    // Example of a while structure<br>    number = 0; // Reset the number<br>    while_function(&amp;mut number);<br>}</div><br></span></pre><br>
<p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15248"></a><h3>1.4. Input from the user, Option and Result type, expect-function</h3><p dir="ltr" style="text-align: left;">Tässä kappaleessa opetellaan kysymään käyttäjältä syötettä, ja parsimaan se tarvittaessa oikeaan muotoon.<br></p>
<p></p>
<p dir="ltr"><br></p>
<h4 dir="ltr">Asking input</h4>
<div>Rust provides standard library tools for asking for user input</div>
<pre><span class="" style="color: rgb(125, 159, 211);">use </span>std::io;<br></pre>
<p>This line invokes the <a href="https://doc.rust-lang.org/std/io/index.html#standard-input-and-output">io module</a> inside Rust's standard library (<a href="https://doc.rust-lang.org/std/index.html">std</a>). io (input/output) provides functionality for reading (<strong>stdin</strong>) and printing (<strong>stdout and stderr</strong>) user input.</p>We will go through the modules in more detail in later sections.<br><br>Let's go through the example code below, section by section, so that we can get an idea of ​​how basic commands for querying and processing input can be used from the io module.<pre><span class="" style="color: rgb(125, 159, 211);"><span class="" style="color: rgb(51, 51, 51);"><span class="" style="color: rgb(125, 159, 211);"><span class="" style="color: rgb(51, 51, 51);">use std::io;</span><br>fn </span>main() {</span><br><span class="" style="color: rgb(51, 51, 51);">    // Asking for a word</span><br><span class="" style="color: rgb(51, 51, 51);">    println!("Enter word:");</span><br><span class="" style="color: rgb(51, 51, 51);">    <span class="" style="color: rgb(125, 159, 211);">let mut</span> word = String::new();</span><br><span class="" style="color: rgb(51, 51, 51);">    <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>word).expect("Error reading input");</span><br><span class="" style="color: rgb(51, 51, 51);">    <span class="" style="color: rgb(125, 159, 211);">let </span>word = word.trim(); // Remove newlines from input</span><br><span class="" style="color: rgb(51, 51, 51);">    println!("You entered a word: {}", word);</span></span><br><br></pre>In the first sections, we print an informative message to the user about what we want from the user. We initialize an empty string variable that is mutable, meaning we can modify it if needed.<br><br>We ask the user for a line, using the <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line </a>function of the stdin submodule of the io module.&nbsp; read_line takes in a mutable variable, and in this case a reference, which is comparable to e.g. to pointer from C++. A reference is identified by the "<strong>&amp;</strong>" sign before the variable, and is related to Rust's Ownership concept, which we will cover in week 2. After the successful execution of a line, the input given by the user, which therefore ends with a new line or, for example, hitting enter at the command prompt, is stored in the variable with a letter.<br><br>Readline is also followed by a simple error handling call, expect, which we will cover later.<br><br>Since the input is saved as is, the input needs to be trimmed using the standard library's trim command. The trim command removes line breaks from input.<br><br>In the example code below, we do the same as just now, but we also use the if statement structure to our advantage and we call the len function from the standard library to find out if the user entered more than one character.<pre><br>    // Let's ask for a letter<br>    println!("Enter letter:");<br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> letter = String::new();<br>    <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;mut letter).expect("Error reading input");<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>letter = letter.trim(); // Remove newlines from input<br>    <span class="" style="color: rgb(125, 159, 211);">if </span>letter.len() == 1 {<br>        println!("You entered a letter: {}", letter);<br>    } <span class="" style="color: rgb(125, 159, 211);">else </span>{<br>        println!("Input should be one letter!");<br>    }<br><br></pre>In the next section, we ask the user for an integer. We create a new variable, which is also of type String, we call the read_line function again, we give as a parameter the integer number of the variable we created called <em>integer </em>with a reference, and at the end there is an error handling statement, <em>expect</em>.<br><br>Since the number is stored in a String variable, the number must be parsed. In this example, we create a new, non-mutable integer variable for this purpose, from which we first remove line breaks with the trim command and then change the String type text to the i32 text type with the parse command of the standard library. At the end we have the error control command, as well as printing.<br><br>Below is a similar example but with a floating point numbers. Remember that saving as a number always requires the use of the parse command. A simple trim is enough for the string types to remove newlines. Remember to use references and mutable variables.<p><span><span><span><em></em></span> </span><em></em></span></p>
<pre><br>    // Asking for an integer<br>    println!("Enter an integer:");<br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> integer = String::new();<br>    <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut</span> integer).expect("Error reading input");<br>    let integer: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= integer.trim().parse().expect("Input is not a valid integer");<br>    println!("You entered an integer: {}", integer);<br><br>    // Querying a floating point number<br>    println!("Enter a floating point number (eg 3.14):");<br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> float = String::new();<br>    <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin().read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>float).expect("Error reading input");<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>float: <span class="" style="color: rgb(125, 159, 211);">f64 </span>= float.trim().parse().expect("Input is not a valid float");<br>    println!("You entered a float: {}", float);<br>}</pre>
<pre><br></pre><strong>Match-statement with input</strong><span><span><br>For example, when asking the user for reading input, you should use the match phrase to utilize the simple structure.<br>Parse returns the Result type, which is a useful and common way to manipulate data in Rust. If there is any data, this data is returned. If an error is found, in this example case we can print the desired error code: Parsing failed. If you examine the structure a bit, you will notice that the structure matches the structure of the match statement. If the parsing was successful, the parsed_int variable can be used normally after this.<br>More about the <a href="https://doc.rust-lang.org/std/result/index.html">Result</a> type and <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">parsing</a>.</span></span><span><span><br></span></span>
<div><pre><br>use std::io;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>    println!("Enter number: ");<br><br>    <span class="" style="color: rgb(125, 159, 211);">let mut </span>user_input = String::new();<br><br>    <span class="" style="color: rgb(239, 69, 64);">io</span>::stdin()<br>        .read_line(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>user_input)<br>        .expect("Error occurred.");<br><br>    <span class="" style="color: rgb(125, 159, 211);">let </span>parsed_int: <span class="" style="color: rgb(125, 159, 211);">i32 </span>= match user_input.trim().parse() {<br>        Ok(number) =&gt; number,<br><br>        Err(_) =&gt; {<br>            println!("Parsing failed.");<br><br>            return;<br>        }<br>    };<br><br>    <span class="" style="color: rgb(125, 159, 211);">if </span>parsed_int &lt; 0 {<br>        println!("Number is less than 0.");<br>    } <span class="" style="color: rgb(125, 159, 211);">else if</span> parsed_int &gt; 100 {<br>        println!("Number is more than 100.");<br>    } <span class="" style="color: rgb(125, 159, 211);">else </span>{<br>        println!("The number is between 0 and 100.");<br>    }<br>}<br><br><br></pre>
    <h5>Except-command</h5>In Rust, expect is a method used with a <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result </a>or <a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option</a> type. It allows simple error handling. If the operation fails, expect prints the associated error message and terminates the program (i.e. panics).<br>Below we see an example of file processing using standard library modules. When we try to open a file, we use expect to tell if the file fails to open.<br>We will go through file processing in more detail in a later chapter.<div><br></div>
    <div>
        <div>
            <pre><span class="" style="color: rgb(125, 159, 211);">use </span>std::fs::File;</pre>
            <pre><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</pre>
            <pre>&nbsp; &nbsp; <span class="" style="color: rgb(125, 159, 211);">let </span>file = <span class="" style="color: rgb(239, 69, 64);">File</span>::open("tiedosto.txt").expect("Failed to open file!");</pre>
            <pre>&nbsp; &nbsp; println!("File opened successfully: {:?}", file);</pre>
            <pre>}</pre><br>
        </div>
    </div>
    <h5>Result and Option -type</h5>
    <h5><span style="font-weight: normal;">Result and Option are special Rust enum types used for safe handling of errors and alternative values. They are an integral part of Rust's way of avoiding "panics" (program crashes, panic in Rust) and using the type system to ensure proper error handling.</span></h5>
    <div><br></div>
    <div><strong>Result</strong></div>
    <div>The Result type is used to indicate either success or error status in operations. It is defined as:</div>
    <div><br></div>
    <pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Result&lt;T, E&gt; {<br>&nbsp;&nbsp;&nbsp; Ok(T),&nbsp; // Has value T if successful<br>&nbsp;&nbsp;&nbsp; Err(E), // Has value E if not successful<br>}<br></pre>
    <ul>
        <li>T is the type for successful return value</li>
        <li>E is the type when error occurs</li>
    </ul>
    <div><br></div>
    <h4>Example:</h4>
</div>
<pre>use std::fs::File;<br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {<br>    <span class="" style="color: rgb(125, 159, 211);">let </span>result = <span class="" style="color: rgb(239, 69, 64);">File</span>::open("existing_nonexistent_file.txt");<br>    <span class="" style="color: rgb(125, 159, 211);">match </span>result {<br>        Ok(file) =&gt; println!("File opened successfully!"),<br>        Err(error) =&gt; println!("Failed to open file: {}", error),<br>    }<br>}</pre>
<p>Here <em>File::open</em> returns <em>Result&lt;File, std::io::Error&gt;</em>. If the file is found, it returns <em>Ok(File)</em>. If the file is not found, it returns<em> Err(std::io::Error)</em>.</p>
<p><br></p>
<p><strong>Option</strong><br></p>
<p>The Option type is used when the value can be present or absent. It is defined as:</p>
<pre><span class="" style="color: rgb(125, 159, 211);">enum </span>Option&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp; Some(T), // When the value exists<br>&nbsp;&nbsp;&nbsp; None,&nbsp;&nbsp;&nbsp; // When the value is missing</pre>
<pre>}</pre>

<ul>
    <li>T is the type that Option can contain</li><li>None means there is no value</li>
</ul>
<div><br></div>
<div><strong>Example:</strong></div>
<div>
    <pre><span><span><span class="" style="color: rgb(125, 159, 211);"><span class="" style="color: rgb(51, 51, 51);"><span class="" style="color: rgb(125, 159, 211);">fn </span>get_value(index: <span class="" style="color: rgb(125, 159, 211);">usize</span>) -&gt; Option&lt;<span class="" style="color: rgb(125, 159, 211);">i32</span>&gt; {</span><br><span class="" style="color: rgb(51, 51, 51);">    <span class="" style="color: rgb(125, 159, 211);">let </span>numbers = vec![10, 20, 30];</span><br><span class="" style="color: rgb(51, 51, 51);">    numbers.get(index).cloned()</span><br><span class="" style="color: rgb(51, 51, 51);">}</span><br><br><span class="" style="color: rgb(51, 51, 51);"><span class="" style="color: rgb(125, 159, 211);">fn </span>main() {</span><br><span class="" style="color: rgb(51, 51, 51);">    <span class="" style="color: rgb(125, 159, 211);">match </span>get_value(1) {</span><br><span class="" style="color: rgb(51, 51, 51);">        Some(value) =&gt; println!("Value found: {}", value),</span><br><span class="" style="color: rgb(51, 51, 51);">        None =&gt; println!("No value found!"),</span><br><span class="" style="color: rgb(51, 51, 51);">    }</span><br><span class="" style="color: rgb(51, 51, 51);">}</span></span></span></span><strong><span></span></strong><br><strong><span></span></strong></pre><strong><span><br></span></strong>
</div>Here, the get method returns an <em>Option&lt;T&gt;</em><span>:</span><br><br><ul><li>&nbsp;&nbsp;&nbsp; If the index is valid, the function returns<em> Some(value)</em></li><li>&nbsp;&nbsp;&nbsp; If the index is not valid, it returns <em>None</em>.</li></ul>Since the given index is 1 in the example, the value was found, the return value is <em>Some(value)</em> and the value is 20.<br><br><br><h5>Unwrap command - a simple way to get data out of Option and Result</h5>unwrap() is a quick way to unwrap values ​​without extra error handling, but it's risky in production code. Panicking in error situations can lead to an unexpected program crash.<br><br><pre><span class="" style="color: rgb(125, 159, 211);">let </span>value: Option&lt;<span class="" style="color: rgb(125, 159, 211);">i32</span>&gt; = 5;<br>println!("Value: {}", value.unwrap()); // Prints: Value: 5</pre><br>The unwrap command can be used instead of the match statement, but it's recommended to use match statement.<br>The unwrap command can be used with all types that return a Result or Option type (e.g. File::open)<br><br><h5>What is the difference between Result and Option type?</h5>The Result type is used when the operation has a chance to fail and you need information related to explaining the error (Err).<br>The Option type is used when a value may be missing, but the reason for the error is not necessary.<br><br><br><h5>What is the benefit of using these types?</h5>Using the Result and Option type helps to avoid null references - Option None replaces the null value known from many languages.<br>These types also ensure that you handle errors explicitly.<div><strong><span><span><span></span></span></span></strong></div>
<div><strong><span><br></span></strong></div>
<h5><span><span><br></span></span></h5><h5><span>What &lt;T&gt;?</span><br><span></span></h5><span>&lt;T&gt; is a generic type parameter in Rust that is used to make functions, structures, methods or enums type-independent. Genericity allows you to write general-purpose code that works with different types without having to repeat the same code for each type separately.<br><br><br></span><h5><span>How does a generic type work?</span><br><span></span></h5><span>&lt;T&gt; acts like a placeholder for the type , which is decided later – either when the code is called or by compiler inference. In Rust, the generic type is always precisely defined at the compilation stage, so the program does not contain additional runtime overhead from genericity. In Rust, the compiler creates separate implementations for all the required types from the generic code (the process is called monomorphization). This means that Generics offer both performance and flexibility without compromising type safety. This topic goes into more detail already as additional information, but was included as an FYI because of the Option type and Result type - these types use the generic value T so that the user can use any type in these.<br><br>More about generic types in chapter 10 of Rust's book.<br><br>More about the Option and Result types in chapter 6.</span><div><span><span><span><span><p><span><span><br></span></span></p>
                </span></span></span></span></div>
<div><br></div><code></code>
<p></p></div><a href="#toc">&uarr; top</a><div class="book_chapter"><a name="ch15249"></a><h3>1.5. use-command</h3><p dir="ltr" style="text-align: left;"></p>
<h4>use-command</h4>
<div>
    <p>In Rust, the use keyword is part of the module system and is used to import names (such as functions, structures, enums, or traits) from other modules or libraries. This makes the code easier to read and avoids the need to write long namespaces repeatedly.</p>
    <p><br></p>
    <h4>use-keyword example</h4>
    <pre>use std::fs::File;<br>use std::io::{self, Read};<br><br><span class="" style="color: rgb(125, 159, 211);">fn </span>main() -&gt; <span class="" style="color: rgb(239, 69, 64);">io</span>::Result&lt;()&gt; {<br>    // Open existing file<br>    <span class="" style="color: rgb(125, 159, 211);">let mut </span>file = <span class="" style="color: rgb(125, 159, 211);">match </span><span class="" style="color: rgb(239, 69, 64);">File</span>::open("example.txt") {<br>        Ok(file) =&gt; file,<br>        Err(e) =&gt; {<br>            eprintln!("Error opening the file: {}", e);<br>            return Err(e);<br>        }<br>    };<br><br>    <span class="" style="color: rgb(125, 159, 211);">let mut</span> content = String::new();<br><br>    // Read the file<br>    <span class="" style="color: rgb(125, 159, 211);">match </span>file.read_to_string(&amp;<span class="" style="color: rgb(125, 159, 211);">mut </span>content) {<br>        Ok(_) =&gt; println!("Contents of the file:\n{}", content),<br>        Err(e) =&gt; {<br>            eprintln!("Error reading the file: {}", e);<br>            return Err(e);<br>        }<br>    }<br><br>    Ok(())<br>}<br><br></pre><p>Our example file:</p><pre><img src="data/kuva.png" alt="" role="presentation" class="img-fluid"><br><br></pre><p>Example output:</p><pre>Contents of the file:<br>Example<br>text<br>here!</pre>
</div>Rust's<a href="https://doc.rust-lang.org/std/fs/index.html"> std::fs</a> module provides all the necessary tools for both reading and writing files.&nbsp; When using the <em>use </em>keyword, we can import modules provided by the fs module into our use. For example:<pre>use std::io::{self, Write};</pre>brings parts of the std-library to our use.<br><br>
<h3>Parts:</h3>
<ol>
    <li>
        <p><strong><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code></strong><span class="" style="color: rgb(51, 51, 51);">:</span></p>
        <ul>
            <li><strong><code><span class="" style="color: rgb(51, 51, 51);">std</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>is Rust's standard library</span></li>
            <li><strong><code><span class="" style="color: rgb(51, 51, 51);">io</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong><span>
 is a module of standard library which offers input- and output 
functionalities like writing to a file, reading and printing and error 
handling</span></span></li>
        </ul>
    </li>
    <li>
        <p><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>self</strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p>
        <ul>
            <li><strong><code><span class="" style="color: rgb(51, 51, 51);">self</span></code></strong><span class="" style="color: rgb(51, 51, 51);"><strong> </strong>implies that the entire <span></span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code> module is imported as is.</span></li>
            <li><span class="" style="color: rgb(51, 51, 51);">This allows you to use e.g. <span></span><span><code><span class="" style="color: rgb(51, 51, 51);">io::Result</span></code><span class="" style="color: rgb(51, 51, 51);">, </span><code><span class="" style="color: rgb(51, 51, 51);">io::Error</span></code></span>, or other properties of the <span><code><span class="" style="color: rgb(51, 51, 51);">std::io</span></code><span class="" style="color: rgb(51, 51, 51);"> </span></span>module directly without the long name<span class="" style="color: rgb(51, 51, 51);"> </span><span><span><code><span class="" style="color: rgb(51, 51, 51);">std::io.</span></code><span> </span></span></span></span></li>
        </ul>
    </li>
    <li>
        <p><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>Write</strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p>
        <ul>
            <li><span class="" style="color: rgb(51, 51, 51);">This introduces the <span> </span><code><span class="" style="color: rgb(51, 51, 51);">Write</span></code> trait, which provides the properties for writing data. For example:</span><ul>
                    <li><span><code><span class="" style="color: rgb(51, 51, 51);"><strong>write</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Writes raw data.</span></span></li>
                    <li><code><span class="" style="color: rgb(51, 51, 51);"><strong>write_all</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Writes all given data.</span></li>
                    <li><code><span class="" style="color: rgb(51, 51, 51);"><strong>writeln!</strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Macro, that writes to one line and writes a newline.</span></li>
                </ul>
            </li>
            <li><code><span class="" style="color: rgb(51, 51, 51);"><strong>Write</strong></span></code><span class="" style="color: rgb(51, 51, 51);">-trait is needed in writing to a file or guiding outputs.</span></li></ul></li><li>
        <p><span><code><span><strong><span class="" style="color: rgb(51, 51, 51);">Read</span></strong></span></code></span><span class="" style="color: rgb(51, 51, 51);">:</span></p>
        <ul>
            <li><span><span class="" style="color: rgb(51, 51, 51);">This introduces the </span><span><span class="" style="color: rgb(51, 51, 51);"> </span><code><span class="" style="color: rgb(51, 51, 51);">Read </span></code></span><span class="" style="color: rgb(51, 51, 51);">trait, which provides the properties for reading data from a file. For example:</span></span><ul>
                    <li><span><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Reads raw data as bytes.</span></span></li>
                    <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read_to_string</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Reads the given data to a String.</span></li>
                    <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">read_exact</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">: Reads the amount of bytes given.</span></li>
                </ul>
            </li>
            <li><code><span><strong><span class="" style="color: rgb(51, 51, 51);">Read</span></strong></span></code><span class="" style="color: rgb(51, 51, 51);">-trait is needed in writing to a file or guiding outputs.</span></li></ul></li>
</ol>By using the <em>use </em><span>keyowrd</span>, we can keep the code clean and easy to read.<br>More about traits in chapter 10 of the book.<p></p></div><a href="#toc">&uarr; top</a>
</body>
</html>